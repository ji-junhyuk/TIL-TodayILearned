# 기초 코드 작성 요령 1
gcc ex01.cpp -lstdc++ -o ex01.o

예를 들어 시간 제한이 1초라고 하면, 이건 "당신의 프로그램은 3-5억 번의 연산 안에 답을 내고 종료되어야 한다"라는걸 알려주는 것입니다.

이렇게 뜯어서 보면 이 함수는 5n + 3번의 연산이 필요하다는걸 알 수 있습니다. n이 100만 정도였으면 대충 500만 번의 연산이 필요하니 1초 안에 충분히 돌거고 n이 10억이었으면 대충 50억 번의 연산이 필요하니 1초 안에 다 돌 수가 없습니다.

그러면 이제 우리가 문제를 풀 때 해야 할 일을 하나 더 알게 됐는데 주어진 문제를 보고 풀이를 떠올린 후에 무턱대고 바로 그걸 짜는게 아니라 내 풀이가 이 문제를 제한 시간 내로 통과할 수 있는지, 즉 내 알고리즘의 시간복잡도가 올바른지를 꼭 생각해봐야 합니다.

대신 문제를 풀 때 어떤 것 하나를 기억해두는게 좋냐면 메모리 제한이 512MB일 때 int 변수를 대략 1.2억개 정도 선언할 수 있다는 것을 기억해두시는게 좋습니다. 이건 int 1개가 4바이트라는 것을 이용해 계산할 수 있습니다.

이걸 기억해두면 만약 떠올린 풀이가 크기가 5억인 배열을 필요로 할 때 해당 풀이는 주어진 메모리 제한을 만족하지 못하므로 틀린 풀이라는 것을 빠르게 깨닫고 다른 풀이를 고민할 수 있습니다. 실컷 다 짠 후에야 알아차리면 너무 억울합니다.

1. 실수의 저장/연산 과정에서 반드시 오차가 발생할 수 밖에 없다. (float: 유효숫자 6자리, long: 유효슛자 15자리)
2. double에 long long 범위의 정수를 함부로 담으면 안된다. (long: 유효숫자 19자리)
3. 실수를 비교할 때는 등호를 사용하면 안된다. (cf.표현식 1e-12, 1e9)

# 기초 코드 작성 요령 2
C에서는 scanf/printf로 입력과 출력을 처리하고 C++에서는 cin/cout을 사용하는데, 기능에 별 차이가 없어서 어느 것을 쓰셔도 상관이 없습니다. 참고로 저는 cin/cout을 사용하긴 합니다.

scanf/printf에서 단 한 가지 아쉬운 점이라고 한다면, C++ string을 처리할 수가 없습니다. 아시다시피 C에서는 char*으로 문자열을 다루는데 사실 char*보다 C++ string이 월등하게 편합니다. 그래서 scanf/printf를 쓰면서도 C++ string을 활용하고 싶으면 일단 char*으로 입력을 받고 string으로 형 변환을 해서 원하는 작업을 다 끝낸 후에 c_str() 메소드를 이용해 출력하면 됩니다.

scanf/printf와 다르게 cin/cout은 입출력으로 인한 시간초과를 막기 위해서 ios::sync_with_stdio(0), cin.tie(0)이라는 두 명령을 실행시켜야 합니다.

그렇기 때문에 C++ stream만 쓸거면 동기화를 끊어버려서 프로그램 수행 시간에서 이득을 챙길 수 있고, 동기화를 끊는 명령이 sync_with_stdio(0)입니다. 대신 동기화를 끊었으면 절대 cout과 printf를 섞어쓰면 안됩니다. 섞어쓰면 지금 코드 출력 결과처럼 순서가 꼬이게 됩니다.  

이런 현상을 막으려고 기본적으로는 cin 명령을 수행하기 전에 cout 버퍼를 비워줍니다.
그런데 온라인 저지 사이트에서는 채점을 할 때 그냥 출력 글자만 확인을 합니다. 그렇기 때문에 콘솔 창에서 입력 글자와 출력 글자 사이에 순서가 설령 꼬인다고 해도 채점에 아무런 영향을 주지 않고 두 경우 모두 다 정답 처리가 됩니다.
그러면 굳이 cin 명령을 수행하기 전에 cout 버퍼를 비울 필요가 없다는걸 알 수 있습니다. 그래서 cin 명령을 수행하기 전에 cout 버퍼를 비우지 않도록 하는 코드가 cin.tie(nullptr)인거고, 엄밀히는 type을 지켜서 nullptr로 쓰는게 좋지만 그냥 타이핑도 아낄겸 0으로 쓰겠습니다.


