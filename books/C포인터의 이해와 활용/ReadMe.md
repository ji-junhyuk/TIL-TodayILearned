# 지은이의 글
포인터는 메모리를 동적으로 다룰 수 있는 메커니즘을 제공하고, 데이터 구조를 더 강력하게 지원하며, 하드웨어에 대한 접근을 가능하게 한다. 포인터의 이런 강력함과 유연함을 공짜로 얻을 수는 없다. 포인터를 완벽하게 마스터 하는 것은 결코 쉬운 일이 아니다.

# Ch1. 시작하기
포인터를 이해하는 열쇠는 C 프로그램에서 메모리가 어떻게 관리되는지 이해하는 데 있다. 결국, 포인터는 메모리의 주소를 담고 있기 때문이다.

- 접근 범위(Scope)와 수명(Lifetime)

||접근범위|수명|
|:----:|:----:|:----:|
|전역|전체파일|애플리케이션 실행 동안 유지|
|정적|선언된 함수|애플리케이션 실행 동안 유지|
|자동(로컬)|선언된 함수|함수 실행 동안 유지|
|동적|참조하는 포인터|메모리 해제 전까지 유지|

- 배열 연결 리스트 vs 포인터 연결 리스트
	- 배열을 사용하여 데이터 구조를 구현할 경우 포인터의 역활을 배열의 인덱스로 대체할 수 있지만, 포인터만큼 직관적이거나 유연하지 못하다.
	- 배열의 크기는 일반적으로 배열이 생성될 때 결정되어 배열이 저장할 수 있는 요소의 수에 제약이 발생한다. 포인터를 사용하면 이러한 제약이 없으며, 새로운 노드가 필요할 때 동적으로 할당할 수 있다.

- 포인터를 초기화하지 않고 사용할 수 있지만, 초기화하기 전까지는 제대로 동작하지 않을 것이다(메모리는 할당될 때 초기화 되지 않기에 이전에 사용된 데이터가 메모리에 존재한다).
- 포인터 선언을 뒤에서 읽음으로써 선언을 점차적으로 이해할 수 있다.
	- 상수 정수를 가리키는 포인터 변수 pci : const int * pci;
- 포인터는 가능한 한 빨리 초기화하는 것이 위와 같은 잘못된 포인터의 사용을 피할 수 있는 좋은 습관이다.
```c
int num;
int *pi = &num;
```
- 널 포인터와 초기화되지 않은 포인터는 명백히 다르다. NULL을 포함한 포인터는 메모리상의 어떤 위치도 참조하지 않지만, 초기화되지 않은 포인터는 어떤 값이라도 포함될 수 있으며 참조될 수 있다.
- 널 포인터가 포함한 주소는 유효한 주소가 아니므로 절대 역참조해서는 안 되며, 널 포인터에 대한 역참조는 프로그램의 비정상 종료를 초래한다.
- 그러나 NULL은 포인터가 아닌 상황에서는 사용하지 말아야 한다. NUL 아스키 문자는 문자 리터럴 '\0'과 같은 뜻이며, 십진수 값 0을 의미한다.
- 포인터의 크기를 알 필요가 있을 때 항상 sizeof 연산자를 사용하도록 하자.

- 포인터 연산자
	- * : 포인터 선언
	- * : 역참조, 포인터 역참조
	- -> : 포인터, 포인터로 참조된 구조체의 멤버 접근
	- + : 더하기, 포인터 증가
	- - : 빼기, 포인터 감소
	- == != : 같음, 같지 않음, 두 포인터의 비교
	- (데이터 타입) : 캐스팅, 포인터 타입 변환
- 포인터는 상수를 가리키도록 정의될 수 있다. 이 말은 곧 포인터는 포인터가 참조하는 값을 수정하는 데 사용될 수 없음을 의미한다.
	- 상수 정수 포인터 (const int * pci)
	- 상수 정수 선언시 const와 type의 순서는 중요하지 않다.
	- pci는 다른 상수 정수를 가리키거나 비상수 정수를 가리키도록 할당될 수 있다. 역참조도 가능하다 (pci = &num) 
	- 단, * pci = 바꿀 값 은 불가하다. (pci 포인터가 가리키는 것이 num 변수 일때도, pci 포인터는 자신이 상수 정수를 가리키고 있다고 판단)
```c
int num;
int *const cpi = &num;
```
- cpi 변수는 비상수 변수로 초기화 되어야 한다.
- cpi 변수는 변경될 수 없다.
- cpi 포인터 변수가 가리키는 변수의 값은 변경할 수 있다.
- 가능
	- * cpi = limit;
	- * cpi = 25;
- 경고 (cpi는 상수 limit을 가리키고 있지만, 상수 limit은 cpi 포인터에 의해 변경될 수 있다)
	- const int limit = 500;
	- int * const cpi = &limit;
- 불가 
	- cpi = &age; 

- 상수를 가리키는 상수포인터
	- 이는 변수의 선언과 동시에 초기화해야 한다.
	- 포인터 데이터의 변경과 포인터에 의해 가리켜진 데이터의 변경이 불가하다.
```c
const int *const cpci = &limit;
//불가 cpci = &num
//불가 *cpci = 25;
```
- 다중 상수 포인터
```c 
const int limit = 500;
const int *const cpci = &limit;
const int *const *pcpi = &cpci;
```
       						포인터 데이터 변경, 포인터 대상 데이터 변경
비상수를 가리키는 포인터  			O		  , 		O
상수를 가리키는 포인터 				O		  , 		X
비상수를 가리키는 상수 포인터  		X		  ,  		X
상수를 가리키는 상수 포인터			X		  , 		X

# Ch2. 동적 메모리 관리
- 포인터의  강력한 기능의 대부분은 동적으로 할당된 메모리를 추적할 수 있는 포인터의 능력에서 기인한다.
- C프로그램은 런타임 시스템(runtime system)안에서 실행된다. 런타임 시스템은 일반적으로 운영체제에서 제공되는 환경이며, 많은 프로그램 기능들과 함께 스택(stack)과 힙(heap)을 지원한다.
cf. 주기억장치를 효율적으로 운영하기 위해서 일정한 크기, 논리적 단위로 나누어서 할당과 할당 해제로 관리하게 된다. 그 논리적 단위를 세그먼트(Segment)라고 하고, 서로 관련이 있는 데이터와 명령어를 하나의 세그먼트로 관리하는 것이 아니라 데이터를 저장하는 데이터 세그먼트(data segment)영역과 명령어를 저장하는 코드 세그먼트(code segment)영역으로 구분해서 사용한다.
- 데이터 세그먼트는 실행 코드와 런타임 시스템에 의해 관리되는 다른 데이터와는 분리된 영역이다.
- C와 같은 언어들은 힙(Heap)에서 메모리를 할당하는 동적 메모리 관리를 지원한다. 동적 메모리 할당은 할당, 해제 함수를 사용하여 수동으로 처리된다. 이를 동적 메모리 관리(dynamic memory management)라고 한다.
- 역참조 연산 시 가장 흔하게 발생하는 오류
```c
int *pi;
*pi = (int *)malloc(sizeof(int));
// pi 정수 포인터에 아직 메모리가 할당되지 않은 상태라면, pi포인터에는 유효하지 않은 값이 포함되어 있다. 그래서 아래와 같이 접근해야 한다.
pi = (int *)malloc(sizeof(int));
```
- 메모리가 할당되면 추가적인 정보가 힙 관리자에 의해 관리되는 데이터 구조의 일부로 저장된다. 
- 메모리 누수
	- 메모리의 주소를 잃어버리는 경우
	- free 함수가 호출되어야 하는 상황에 호출되지 않은 경우
	- 메모리 누수의 문제점은 해당 메모리가 반환되지 않고 다시 사용될 수 없다는 것이다. 그 결과 힙 관리자가 사용할 수 있는 메모리의 양이 감소한다.
```c
char *chunk
while (1)
{
	chunk = (char *)malloc(100000);
	printf("Aloocating\n");
}

// 메모리 주소 손실 -> 메모리 주소가 해제 되지 않은 상태이며, 프로그램 어디에서도 이 주소를 알지 못함.
int *pi = (int *)malloc(sizeof(int));
*pi = 5;
...
pi = (int *)malloc(sizeof(int));

// 메모리 시작 주소 잃어버림
char *name = (char *)malloc(strlen("junto")+1);
strcpy(name, "junto");
while (*name != 0)
{
	printf("%c", *name);
	name++;
}
```
- 메모리 주소 손실
- 숨겨진 메모리 누수
	- 할당된 메모리가 더는 필요하지 않은 순간에도 힙에 유지 될 때 발생한다.
	- 큰 문제점은 더는 필요하지 않으며, 반환될 필요가 있는 메모리를 계속 붙잡고 있다는 것이다.
	
- 동적 메모리 할당 함수
	- malloc : 힙에서 메모리 할당
	- calloc : 힙에서 메모리 할당 그리고 0으로 설정
	- realloc : 기존 할당된 메모리의 크기 변경
	- free : 할당된 메모리를 힙으로 반환
- 반복적인 메모리 할당 호출은 할당된 메모리의 순서나 연속성에 대해 보장해주지 않는다.
- 그러나 할당된 메모리는 포인터의 데이터 타입에 따라 정렬된다.
- malloc 함수
	- 프로토타입 : void * malloc(size_t);
	- 일반적으로 다음과 같이 사용한다.
	int *pi = (int *)malloc(sizeof(int));
	- malloc 함수가 호출되면 아래 단계가 수행된다.
		- 힙 영역에서 메모리가 할당된다.
		- 메모리는 수정되거나 초기화되지 않는다.
		- 첫 번째 시작 주소가 반환된다.
		malloc 함수는 메모리 할당할 수 없을 때 NULL을 반환하기에 반환 주소를 사용하기 전에 검사하는 것이 좋다.
		int *pi = (int *)malloc(sizeof(int));
		if (pi != NULL)
		{
			//할당 성공
		}
		else 
			//할당 실패
- 캐스팅은 꼭 필요한가
	- void 포인터가 어느 타입의 포인터에도 할당이 가능해졌으므로, 명시적 호출은 더 이상 필요하지 않다.
	- 하지만 몇몇 개발자들은 다음과 같은 이유로 명시적 캐스팅이 좋은 습관이라 한다.
		- 명시적 캐스팅은 malloc함수의 사용 의도를 명확히 한다.
		- 명시적 캐스팅을 필요로 하는 C++ 또는 초기 C컴파일러와 호환 가능한 코드를 생성한다.

- malloc 함수에 적절하지 않은 크기 사용
	- 총 10개의 double 값을 위한 메모리 공간 할당(80바이트)
		- double * pd = (double *)malloc(NUMBER_OF_DOUBLES * sizeof(double));
		- 잘못된 예(단지 10바이트만 할당)
			const int NUMBER_OF_DOUBLES = 10;
			double *pd = (double *)malloc(NUMBER_OF_DOUBLES);
- 할당된 메모리 크기 알아내기
	- 힙에 의한 할당된 메모리의 전체 양을 알아내는 일반적인 방법은 존재하지 않는다. 또한 힙 관리자에 의해 할당된 메모리 블록의 크기를 알아내는 일반적인 방법도 존재하지 않는다.
	- 문자열 64바이트에 할당하면 힙 관리자는 이 블록을 관리하기 위해 추가로 메모리를 할당한다(64바이트 + 관리용 메모리 영역)

- 정적 포인터 및 전역 포인터에 malloc 사용하기
	- 정적 변수나 전역 변수는 선언 시 초기화를 위해 함수 호출을 사용할 수 없다.
	- static int * pi = malloc(sizeof(int)); // 컴파일 에러, 전역 변수도 마찬가지
	- 컴파일러 관점에서 초기화 연산자(=)의 사용과 할당 연산자(=)의 사용은 차이가 있다.
```c
static int * pi;
pi = malloc(sizeof(int));
// 정적 변수는 오류 피할 수 있다.
// 전역 변수는 함수 바깥에 선언되어야 하기 때문에 정적 변수와 달리 선언과 초기화를 분리할 수 없다.
```

- calloc 함수 사용하기
	- 메모리 할당과 동시에 초기화한다. 할당된 메모리의 첫 바이트를 가리키는 포인터를 반환한다.
	- 메모리를 할당할 수 없는 경우 NULL을 반환
	- 인자 중 하나라도 값이 0이면 NULL을 반환한다. 전역 변수 errno는 ENOMEM(out of memory)로 설정된다.
	- void * calloc(size_t numElements, size_t elementSize);
```c
int *pi = calloc(5, sizeof(int));
// malloc 함수와 memset 함수를 같이 사용하면 같은 결과를 얻는다.
int *pi = malloc(5 * sizeof(int));
memset(pi, 0, 5 * sizeof(int));
```
- memset 함수는 메모리 영역을 원하는 값으로 채운다. 첫 번째 인자는 메모리 영역에 대한 포인터다. 두 번째 인자는 메모리를 채우는 데 사용할 값이며, 마지막 인자는 채울 바이트 수를 나타낸다.
- 메모리 할당과 동시에 0으로 설정할 필요가 있을 때 calloc 함수를 사용하도록 하자. 그러나 calloc 함수의 실행이 malloc보다 더 길다

- realloc 함수 사용하기

# Ch3. 포인터와 함수
# Ch4. 포인터와 배열
# Ch5. 포인터와 문자열
# Ch6. 포인터와 구조체
# Ch7. 보안 이슈와 포인터의 오남용
# Ch8. 기타
