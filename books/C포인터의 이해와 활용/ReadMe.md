# 지은이의 글
포인터는 메모리를 동적으로 다룰 수 있는 메커니즘을 제공하고, 데이터 구조를 더 강력하게 지원하며, 하드웨어에 대한 접근을 가능하게 한다. 포인터의 이런 강력함과 유연함을 공짜로 얻을 수는 없다. 포인터를 완벽하게 마스터 하는 것은 결코 쉬운 일이 아니다.

# Ch1. 시작하기
포인터를 이해하는 열쇠는 C 프로그램에서 메모리가 어떻게 관리되는지 이해하는 데 있다. 결국, 포인터는 메모리의 주소를 담고 있기 때문이다.

- 접근 범위(Scope)와 수명(Lifetime)

||접근범위|수명|
|:----:|:----:|:----:|
|전역|전체파일|애플리케이션 실행 동안 유지|
|정적|선언된 함수|애플리케이션 실행 동안 유지|
|자동(로컬)|선언된 함수|함수 실행 동안 유지|
|동적|참조하는 포인터|메모리 해제 전까지 유지|

- 배열 연결 리스트 vs 포인터 연결 리스트
	- 배열을 사용하여 데이터 구조를 구현할 경우 포인터의 역활을 배열의 인덱스로 대체할 수 있지만, 포인터만큼 직관적이거나 유연하지 못하다.
	- 배열의 크기는 일반적으로 배열이 생성될 때 결정되어 배열이 저장할 수 있는 요소의 수에 제약이 발생한다. 포인터를 사용하면 이러한 제약이 없으며, 새로운 노드가 필요할 때 동적으로 할당할 수 있다.

- 포인터를 초기화하지 않고 사용할 수 있지만, 초기화하기 전까지는 제대로 동작하지 않을 것이다(메모리는 할당될 때 초기화 되지 않기에 이전에 사용된 데이터가 메모리에 존재한다).
- 포인터 선언을 뒤에서 읽음으로써 선언을 점차적으로 이해할 수 있다.
	- 상수 정수를 가리키는 포인터 변수 pci : const int * pci;
- 포인터는 가능한 한 빨리 초기화하는 것이 위와 같은 잘못된 포인터의 사용을 피할 수 있는 좋은 습관이다.
```c
int num;
int *pi = &num;
```
- 널 포인터와 초기화되지 않은 포인터는 명백히 다르다. NULL을 포함한 포인터는 메모리상의 어떤 위치도 참조하지 않지만, 초기화되지 않은 포인터는 어떤 값이라도 포함될 수 있으며 참조될 수 있다.
- 널 포인터가 포함한 주소는 유효한 주소가 아니므로 절대 역참조해서는 안 되며, 널 포인터에 대한 역참조는 프로그램의 비정상 종료를 초래한다.
- 그러나 NULL은 포인터가 아닌 상황에서는 사용하지 말아야 한다. NUL 아스키 문자는 문자 리터럴 '\0'과 같은 뜻이며, 십진수 값 0을 의미한다.
- 포인터의 크기를 알 필요가 있을 때 항상 sizeof 연산자를 사용하도록 하자.

- 포인터 연산자
	- * : 포인터 선언
	- * : 역참조, 포인터 역참조
	- -> : 포인터, 포인터로 참조된 구조체의 멤버 접근
	- + : 더하기, 포인터 증가
	- - : 빼기, 포인터 감소
	- == != : 같음, 같지 않음, 두 포인터의 비교
	- (데이터 타입) : 캐스팅, 포인터 타입 변환
- 포인터는 상수를 가리키도록 정의될 수 있다. 이 말은 곧 포인터는 포인터가 참조하는 값을 수정하는 데 사용될 수 없음을 의미한다.
	- 상수 정수 포인터 (const int * pci)
	- 상수 정수 선언시 const와 type의 순서는 중요하지 않다.
	- pci는 다른 상수 정수를 가리키거나 비상수 정수를 가리키도록 할당될 수 있다. 역참조도 가능하다 (pci = &num) 
	- 단, * pci = 바꿀 값 은 불가하다. (pci 포인터가 가리키는 것이 num 변수 일때도, pci 포인터는 자신이 상수 정수를 가리키고 있다고 판단)
```c
int num;
int *const cpi = &num;
```
- cpi 변수는 비상수 변수로 초기화 되어야 한다.
- cpi 변수는 변경될 수 없다.
- cpi 포인터 변수가 가리키는 변수의 값은 변경할 수 있다.
- 가능
	- * cpi = limit;
	- * cpi = 25;
- 경고 (cpi는 상수 limit을 가리키고 있지만, 상수 limit은 cpi 포인터에 의해 변경될 수 있다)
	- const int limit = 500;
	- int * const cpi = &limit;
- 불가 
	- cpi = &age; 

- 상수를 가리키는 상수포인터
	- 이는 변수의 선언과 동시에 초기화해야 한다.
	- 포인터 데이터의 변경과 포인터에 의해 가리켜진 데이터의 변경이 불가하다.
```c
const int *const cpci = &limit;
//불가 cpci = &num
//불가 *cpci = 25;
```
- 다중 상수 포인터
```c 
const int limit = 500;
const int *const cpci = &limit;
const int *const *pcpi = &cpci;
```
       						포인터 데이터 변경, 포인터 대상 데이터 변경
비상수를 가리키는 포인터  			O		  , 		O
상수를 가리키는 포인터 				O		  , 		X
비상수를 가리키는 상수 포인터  		X		  ,  		X
상수를 가리키는 상수 포인터			X		  , 		X

# Ch2. 동적 메모리 관리
- 포인터의  강력한 기능의 대부분은 동적으로 할당된 메모리를 추적할 수 있는 포인터의 능력에서 기인한다.
- C프로그램은 런타임 시스템(runtime system)안에서 실행된다. 런타임 시스템은 일반적으로 운영체제에서 제공되는 환경이며, 많은 프로그램 기능들과 함께 스택(stack)과 힙(heap)을 지원한다.
cf. 주기억장치를 효율적으로 운영하기 위해서 일정한 크기, 논리적 단위로 나누어서 할당과 할당 해제로 관리하게 된다. 그 논리적 단위를 세그먼트(Segment)라고 하고, 서로 관련이 있는 데이터와 명령어를 하나의 세그먼트로 관리하는 것이 아니라 데이터를 저장하는 데이터 세그먼트(data segment)영역과 명령어를 저장하는 코드 세그먼트(code segment)영역으로 구분해서 사용한다.
- 데이터 세그먼트는 실행 코드와 런타임 시스템에 의해 관리되는 다른 데이터와는 분리된 영역이다.
- C와 같은 언어들은 힙(Heap)에서 메모리를 할당하는 동적 메모리 관리를 지원한다. 동적 메모리 할당은 할당, 해제 함수를 사용하여 수동으로 처리된다. 이를 동적 메모리 관리(dynamic memory management)라고 한다.
- 역참조 연산 시 가장 흔하게 발생하는 오류
```c
int *pi;
*pi = (int *)malloc(sizeof(int));
// pi 정수 포인터에 아직 메모리가 할당되지 않은 상태라면, pi포인터에는 유효하지 않은 값이 포함되어 있다. 그래서 아래와 같이 접근해야 한다.
pi = (int *)malloc(sizeof(int));
```
- 메모리가 할당되면 추가적인 정보가 힙 관리자에 의해 관리되는 데이터 구조의 일부로 저장된다. 
- 메모리 누수
	- 메모리의 주소를 잃어버리는 경우
	- free 함수가 호출되어야 하는 상황에 호출되지 않은 경우
	- 메모리 누수의 문제점은 해당 메모리가 반환되지 않고 다시 사용될 수 없다는 것이다. 그 결과 힙 관리자가 사용할 수 있는 메모리의 양이 감소한다.
```c
char *chunk
while (1)
{
	chunk = (char *)malloc(100000);
	printf("Aloocating\n");
}

// 메모리 주소 손실 -> 메모리 주소가 해제 되지 않은 상태이며, 프로그램 어디에서도 이 주소를 알지 못함.
int *pi = (int *)malloc(sizeof(int));
*pi = 5;
...
pi = (int *)malloc(sizeof(int));

// 메모리 시작 주소 잃어버림
char *name = (char *)malloc(strlen("junto")+1);
strcpy(name, "junto");
while (*name != 0)
{
	printf("%c", *name);
	name++;
}
```
- 메모리 주소 손실
- 숨겨진 메모리 누수
	- 할당된 메모리가 더는 필요하지 않은 순간에도 힙에 유지 될 때 발생한다.
	- 큰 문제점은 더는 필요하지 않으며, 반환될 필요가 있는 메모리를 계속 붙잡고 있다는 것이다.
	
- 동적 메모리 할당 함수
	- malloc : 힙에서 메모리 할당
	- calloc : 힙에서 메모리 할당 그리고 0으로 설정
	- realloc : 기존 할당된 메모리의 크기 변경
	- free : 할당된 메모리를 힙으로 반환
- 반복적인 메모리 할당 호출은 할당된 메모리의 순서나 연속성에 대해 보장해주지 않는다.
- 그러나 할당된 메모리는 포인터의 데이터 타입에 따라 정렬된다.
- malloc 함수
	- 프로토타입 : void * malloc(size_t);
	- 일반적으로 다음과 같이 사용한다.
	int *pi = (int *)malloc(sizeof(int));
	- malloc 함수가 호출되면 아래 단계가 수행된다.
		- 힙 영역에서 메모리가 할당된다.
		- 메모리는 수정되거나 초기화되지 않는다.
		- 첫 번째 시작 주소가 반환된다.
		malloc 함수는 메모리 할당할 수 없을 때 NULL을 반환하기에 반환 주소를 사용하기 전에 검사하는 것이 좋다.
		int *pi = (int *)malloc(sizeof(int));
		if (pi != NULL)
		{
			//할당 성공
		}
		else 
			//할당 실패
- 캐스팅은 꼭 필요한가
	- void 포인터가 어느 타입의 포인터에도 할당이 가능해졌으므로, 명시적 호출은 더 이상 필요하지 않다.
	- 하지만 몇몇 개발자들은 다음과 같은 이유로 명시적 캐스팅이 좋은 습관이라 한다.
		- 명시적 캐스팅은 malloc함수의 사용 의도를 명확히 한다.
		- 명시적 캐스팅을 필요로 하는 C++ 또는 초기 C컴파일러와 호환 가능한 코드를 생성한다.

- malloc 함수에 적절하지 않은 크기 사용
	- 총 10개의 double 값을 위한 메모리 공간 할당(80바이트)
		- double * pd = (double *)malloc(NUMBER_OF_DOUBLES * sizeof(double));
		- 잘못된 예(단지 10바이트만 할당)
			const int NUMBER_OF_DOUBLES = 10;
			double *pd = (double *)malloc(NUMBER_OF_DOUBLES);
- 할당된 메모리 크기 알아내기
	- 힙에 의한 할당된 메모리의 전체 양을 알아내는 일반적인 방법은 존재하지 않는다. 또한 힙 관리자에 의해 할당된 메모리 블록의 크기를 알아내는 일반적인 방법도 존재하지 않는다.
	- 문자열 64바이트에 할당하면 힙 관리자는 이 블록을 관리하기 위해 추가로 메모리를 할당한다(64바이트 + 관리용 메모리 영역)

- 정적 포인터 및 전역 포인터에 malloc 사용하기
	- 정적 변수나 전역 변수는 선언 시 초기화를 위해 함수 호출을 사용할 수 없다.
	- static int * pi = malloc(sizeof(int)); // 컴파일 에러, 전역 변수도 마찬가지
	- 컴파일러 관점에서 초기화 연산자(=)의 사용과 할당 연산자(=)의 사용은 차이가 있다.
```c
static int * pi;
pi = malloc(sizeof(int));
// 정적 변수는 오류 피할 수 있다.
// 전역 변수는 함수 바깥에 선언되어야 하기 때문에 정적 변수와 달리 선언과 초기화를 분리할 수 없다.
```

- calloc 함수 사용하기
	- 메모리 할당과 동시에 초기화한다. 할당된 메모리의 첫 바이트를 가리키는 포인터를 반환한다.
	- 메모리를 할당할 수 없는 경우 NULL을 반환
	- 인자 중 하나라도 값이 0이면 NULL을 반환한다. 전역 변수 errno는 ENOMEM(out of memory)로 설정된다.
	- void * calloc(size_t numElements, size_t elementSize);
```c
int *pi = calloc(5, sizeof(int));
// malloc 함수와 memset 함수를 같이 사용하면 같은 결과를 얻는다.
int *pi = malloc(5 * sizeof(int));
memset(pi, 0, 5 * sizeof(int));
```
- memset 함수는 메모리 영역을 원하는 값으로 채운다. 첫 번째 인자는 메모리 영역에 대한 포인터다. 두 번째 인자는 메모리를 채우는 데 사용할 값이며, 마지막 인자는 채울 바이트 수를 나타낸다.
- 메모리 할당과 동시에 0으로 설정할 필요가 있을 때 calloc 함수를 사용하도록 하자. 그러나 calloc 함수의 실행이 malloc보다 더 길다

- realloc 함수 사용하기
	- void * realloc(void * ptr, size_t size);
	- 첫 번째 인자는 기존 할당된 메모리에 대한 포인터이며, 두 번째 인자는 요청할 메모리의 크기다.
	- 재할당된 메모리의 크기는 기존 메모리의 크기와 다르며, 반환 값은 재할당된 메모리의 포인터이다.
	- 새로 요청된 크기가 기존 크기보다 작으면 여분의 메모리는 힙으로 반환된다. 그리고 반환된 여분의 메모리의 초기화 여부는 보장되지 않는다.
	- 새로 요청된 크기가 기존 크기보다 크면 가능한 한 현재 메모리 영역의 바로 인접 영역에 이어서 메모리 할당한다.
	- 인접 영역에 메모리를 할당할 수 없는 경우, 힙의 다른 영역에 메모리를 할당하고 기존 메모리의 내용을 새로운 영역으로 복사한다.
	- 인자에 따른 realloc 함수 동작
		- (NULL), NA(바이트 수) : malloc 함수와 동일
		- (NULL아님), 0 : 기존 메모리 해제
		- (NULL아님), 기존 메모리 크기보다 작음 : 현재 메모리 영역 사용하여 작은 메모리 영역을 할당
		- (NULL아님), 기존 메모리 크기보다 큼 : 현재 메모리 영역이나 다른 메모리 영역을 사용하여 큰 메모리 영역 할당
```c
char *string1;
char *string2;
string1 = (char *)malloc(16);
strcpy = (string1, "0123456789AB");

string2 = realloc(string1, 8);
printf("%p %s\n", string1, string1); // 주소 500번지
printf("%p %s\n", string2, string2); // 주소 500번지 

// 추가적인 메모리 재할당
string1 = (char *)malloc(16);
strcpy(string1, "0123456789AB");
string2 = realloc(string1, 64);
printf("%p %s\n" stirng1, string1); // 주소 500번지
printf("%p %s\n" stirng2, string2); // 주소 600번지
```
- alloca 함수(=malloca)와 가변 길이 배열
	- 함수 내부에서 사용할 목적으로 스택 프레임 안의 메모리를 할당한다.
	- 함수(스택 프레임을 소유한)가 반환되면 alloca에 의해 할당된 메모리는 자동으로 해제된다.
	- 런타인 시스템이 스택 기반이 아니면 구현하거나 지원할 수 없다. (이식성 낮음)
	- 가변 길이 배열
	```c
	void compute(int size) {
		char buffer[size];
		...
	}
	```
	- 배열을 위한 메모리의 할당이 런타임에 결정되며, 스택 프레임 일부에 메모리가 할당된다. 또한, sizeof 연산자가 가변 길이 배열과 함께 사용되면 
	sizeof 연산자는 컴파일이 아닌 런타임에 실행된다.
	- 가변길이 배열은 함수 내에서 이미 크기가 결정된 다음에는 변경할 수 없다(메모리 해제시 free함수도 필요 없다);
	- 가변 길이 배열을 사용한 함수는 이 메모리에 대한 포인터를 반환해서는 안된다.

- free함수로 메모리 반환하기
	- void free(void * ptr);
	- free 함수의 인자는 malloc 타입 함수에 의해 할당된 메모리 주소를 전달받는다. 그리고 지정된 메모리는 힙 영역으로 반환된다.
	- 반환 후에도 여전히 포인터는 해당 메모리 영역을 가리킬 수 있으나 가비지 영역을 가리킨다고 가정한다. 힙으로 반환된 영역은 나중에 재할당될 수 있다.
```c
int *pi = (int *)malloc(sizeof(int));
...
free(pi);
```
- 주소 500의 점선으로 된 상자는 메모리가 해제 되었으나 여전히 그 값을 포함하고 있다. 포인터 변수 pi는 여전히 주소 500을 가리키고 있다. 이를 댕글링 포인터라 한다.
- 메모리 할당/ 해제를 같은 수준에서 관리하도록 하자. 특정 함수 안에서 할당되었다면 그 함수 내에서 해제하도록 하자. (저자의 권고사항)
- free 함수를 이용한 메모리 해제
	- free 함수 호출 시 인자로 널 포인터를 전달하면, 일반적으로 free 함수는 아무 일도 하지 않는다.
	- malloc 타입의 함수가 아닌 다른 함수에 의해 할당된 포인터를 인자로 전달했을 때 free 함수의 행동은 정의되어 있지 않다.
```c
int num;
int *pi = &num;
free(pi); // 정의되지 않은 행동
```
- 해제된 포인터에 NULL 할당하기
	- 포인터는 메모리가 해제된 이후에도 문제를 유발할 수 있다.
	- 메모리가 해제된 포인터를 역참조하면, 그 포인터의 행동은 정의되어 있지 않다.
	- 그 결과 몇몇 프로그래머들은 해제된 포인터가 더는 유효하지 않음을 표시하기 위해 명시적으로 NULL을 할당한다.
	- 이미 해제된 포인터의 사용은 런타임 예욍를 발생시킨다.
```c
int *pi = (int *)malloc(sizeof(int));
...
free(pi);
pi = NULL;
// 이 기법은 댕글링 포인터 같은 문제를 해결하기 위한 것이다. 하지만 단순히 널 포인터인지를 체크 하는 것보다는 문제를 발생시킨 상황을 해결하는 데 시간을 들이는 것이 낫다. 게다가, 초기화할 때를 제외하고는 상수에 NULL을 할당할 수 없다.
```
- 이중 해제(Double Free)란 메모리 해제를 두 번 시도하는 것을 말한다.
```c
// ex1
int *pi = (int *)malloc(sizeof(int));
*pi = 5;
free(pi);
...
free(pi);

// ex2
p1 = (int *)malloc(sizeof(int));
int *p2 = p1;
free(p1);
...
free(p2);

// 두 경우 모두다 런타임 에러 발생
```
- 힙 관리자는 메모리가 이미 해제되었는지 판단하지 못한다. 게다가 힙 관리자는 같은 메모리가 두 번 해제되려고 하는지도 발견하지 못한다. 메모리의 이중 해제 시도는 일반적으로 메모리를 손상시키거나 프로그램을 종료시킨다. 프로그램 종료와 같은 최악의 상황을 피하더라도 프로그램의 오작동을 유발한다. 일반적으로 해제된 메모리를 다시 해제하는 일은 발생하지 않는다. 
- free 함수가 메모리 해제 후 인자로 전달한 메모리의 포인터 반환 시, NULL 또는 약속된 특별한 값을 할당할 필요가 있다고 생각할지도 모른다. 그러나 포인터가 값으로(by value) 전달 되었기 때문에 free 함수는 명시적으로 인자로 전달된 포인터에 NULL을 할당할 수 없다.

- 힙 메모리와 시스템 메모리
	- free 함수가 호출되었다고 해서 힙 관리자가 반드시 해제된 메모리를 운영체제로 반환하는 것은 아니고, 애플리케이션에서 해당 메모리를 다시 사용할 수 있게 할 뿐이다. 그래서 프로그램이 메모리를 할당한 후 다시 해제한다고 해도, 일반적으로 운영체제 측면에서는 해제된 메모리가 애플리케이션의 메모리 사용량에 반영되지 않는다.

- 프로그램 종료시 메모리 해제
	- 운영체제는 메모리를 포함한 애플리케이션 리소스의 관리 책임이 있다. 운영체제는 애플리케이션 종료 시 사용된 메모리를 다른 애플리케이션이 재할당할 수 있도록 해야 하며, 종료된 애플리케이션의 메모리 상태가 손상되었는지는 중요하지 않다. ... 비정상 종료되는 프로그램이 메모리를 초기화하고 반환하는 일은 사실상 불가능하다. 그래서 사실, 애플리케이션의 종료 전에 메모리를 꼭 해제해야 할 필요는 없다.
	- 메모리가 해제 되어야 하는 다른 이유가 있을 수 있다. 양심적인 개발자들은 소프트웨어의 품질 문제로 메모리 해제를 원할 수도 있다. 비록 애플리케이션이 종료된다고 해도 더는 필요하지 않은 메모리를 해제하는 것은 좋은 습관이다.
	- 메모리 해제를 보장하는 일은 다음 사항을 고려해야 한다.
	1. 메모리 해제의 중요성에 비해 구현하기가 꽤 까다롭다.
	2. 구현에 따로 시간을 써야 하며, 복잡한 구초제의 경우 구현이 더 복잡하다.
	3. 애플리케이션의 크기가 늘어난다.
	4. 애플리케이션의 실행 시간이 길어진다.
	5. 메모리 해제 코드에서 새로운 오류가 발생하기 도한다.
	- 프로그램 종료 전에 메모리를 해제할 지 여부는 어디까지나 애플리케이션 구현에 달려있다.
- 댕글링 포인터(여전히 해제된 메모리 영역을 가리키는 포인터)
	- 댕글링 포인터가 가리키는 메모리는 더는 유효하지 않다(너무 빠른 해제, premature free 라고 불리기도 한다).
	- 아래 문제를 포함한 다양한 문제 발생
	1. 메모리 접근 시 예측 불가능한 동작
	2. 메모리 접근 불가 시 세그멘테이션 오류(Segmentation fault)
	3. 잠재적인 보안 위험
	- 다음과 같은 동작의 결과로 발생
	1. 메모리 해제 후, 해제된 메모리에 접근
	2. 함수 호출에서 자동 변수를 가리키는 포인터의 반환
```c
int *pi = (int *)malloc(sizeof(int));
*pi = 5;
printf("*pi: %d\n", *pi);
free(pi);
*pi = 10;
// 여전히 해당 메모리에 접근하여 쓰기를 시도할 수 있으며, 이러한 시도의 결과는 예측할 수 없다.

int *p1 = (int *)malloc(sizeof(int));
*p1 = 5;
...
int *p2;
p2 = p1;
...
free(p1);
...
*p2 = 10; // 포인터 에일리어싱에(Aliasing) 의한 댕글링 포인터
```
```c
// 블록 구문이 다를 때 생기는 댕글링 포인터
int *pi
...
{
	int tmp = 5;
	pi = &tmp;
}
// 이 위치에서 pi는 댕글링 포인터가 된다. (변수 temp는 블록이 닫힐 때 스택에서 제거되어 tmp의 주소가 더이상 유효하지 않기 때문)
```
- 댕글링 포인터 다루기
	- 메모리 해제 후 포인터를 NULL로 설정하라. NULL로 설정한 포인터를 그 이후에 사용하면 애플리케이션이 종료될 것이다. (다수의 복사본이 있는 경우 여전히 문제 발생)
	- free 함수를 대체할 새로운 함수를 작성하라.
	- 몇몇 런타임 시스템이나 디버깅 ㅅ세스템은 해제된 메모리를 특별한 값으로 덮어쓴다.
	- 서드파티 도구 사용하라.

- 가비지 컬렉션
	- 할당이 해제된 메모리를 가비지(garbage)라고 하며, 가비지 컬렉션이라는 용어는 메모리의 처리를 의미한다.

# Ch3. 포인터와 함수
- 포인터와 함수를 사용할 때, 두 부분에서 포인터가 유용하게 사용된다. 첫 번째는 포인터를 함수에 전달할 때이다. 포인터를 함수로 전달하면 함수는 함수에 의해 참조되는 데이터를 수정할 수 있고, 함수는 덩치가 큰 데이터를 효과적으로 전달할 수 있다.
- 두 번 째는 함수 포인터의 선언이다. 본질적으로 일반적인 함수 표기법이 곧 함수 포인터 표기법이며, 함수의 이름이 곧 함수의 주소로 다뤄지고 매개변수가 함수에 전달된다. 그리고 함수 포인터는 프로그램의 실행 흐름을 제어하는 추가적인 기능을 제공한다.
- 로컬 변수는 자동 변수라고도 불리며, 항상 스택 프레임에 위치한다.
- 프로그램 스택
	- 함수의 실행을 지원하기 위한 메모리 영역이며, 일반적으로 힙과 공유된다.
	- 공유된 메모리 영역에서 프로그램 스택은 메모리의 낮은 부분을 사용하는 경향이 있고, 힙은 메모리의 높은 부분을 사용한다.
	- 프로그램 스택은 스택 프레임을 포함하며, 스택 프레임은 활성화 레코드, 활성화 프레임으로 불리기도 한다. (스택 프레임은 함수 호출 시 전달되는 매개변수와 로컬 변수를 포함한다)
	- 함수 호출 시, 함수의 스택 프레임이 스택에 추가(push)되며, 입력된 스택은 위쪽으로 자란다. 함수가 종료 될때 함수의 스택 프레임이 제거(pop) 된다. 
	- 스택 프레임에 의해 사용된 메모리는 초기화되지 않으며, 다른 스택 프레임에 입력될 때 결국 덮어쓰인다.
- 스택프레임의 구성
	- 반환 주소: 함수 종료 후 돌아가야 할 프로그램 내의 주소
	- 로컬 변수 저장소: 로컬 변수를 위해 할당된 메모리
	- 매개변수 저장소: 함수의 매개변수를 위해 할당된 메모리
	- 스택 포인터와 기반 포인터(base pointer): 스택 관리 목적으로 런타임 시스템에 의해 사용되는 포인터
	- 일반적으로 프로그래머들은 스텍 포인터와 기반 포인터에 대해 신경쓰지 않는다. 그러나 이 두개의 포인터를 이해하는 것이 프로그램 스택을 더욱 깊이 이해하는 데 도움이 된다. 스택 포인터는 일반적으로 스택의 제일 높은 주소를 가리킨다.
	- 스택 기반 포인터가 종종 존재하는데 반환 주소 같은 스택 프레임 안에 있는 주소를 가리키며 스택 프레임 요소들의 접근을 돕는다.
	- 지금 설명하는 이 두 포인터는 C포인터가 아니고 프로그램 스택을 관리하는 런타임 시스템에서 사용하는 주소다. 그러나 C에서 런타임 시스템을 구현하는 경우 이 포인터들이 실제 C 포인터일수도 있다.
	- 매개변수와 로컬 변수 사이의 주소 차이는 스택을 관리하기 위해 런타임 시스템에 의해 사용되는 스텍 프레임의 다른 요소들에 의해 발생한다 (wsl에선 sum->size->arr순으로 높은 메모리에 생김)
	- 매개변수들이 선언과 반대 순서로 스택 프레임에 추가되며 뒤따라 로컬 변수가 생성된다.
	- 스텍 프레임이 프로그램 스텍에 입력될 때, 메모리 부족 상태가 발생할 수 있다. 이를 스택 오버플로(stack overflow)라고 하며 일반적으로 프로그램의 비정상 종료를 초래한다.
- 포인터에 의한 전달과 반환
	- 포인터를 함수로 전달하면 해당 개체를 전역으로 만들지 않고도 다양한 함수에서 참조가 가능하다.
	- 함수 내에서 인자로 전달된 데이터를 수정할 필요가 있는 경우, 인자를 포인터로 전달하면 된다. 그리고 데이터를 포인터로 전달하면서 해당 포인터를 상수 포인터로 전달하면 함수 내에서 데이터가 수정되는 것을 방지할 수 있다.
	- 포인터를 포함한 매개변수들은 값(by value)로 전달된다. 다시말해, 인자의 복사본이 함수로 전달된다. 인자로 포인터를 전달하는 방법은 큰 데이터를 전달할 때 효과적이다.

- 포인터로 전달하기
	- 데이터를 포인터로 전달해야 하는 가장 큰 이유는 함수 내에서 데이터를 수정하기 위해서이다.
```c
void swapWithPointers(int *pnum1, int *pnum2)
{
	int tmp;
	tmp = *pnum1;
	*pnum1 = *pnum2;
	*pnum2 = tmp;
}

int main()
{
	int n1 = 5;
	int n2 = 10;
	swapWthiPointers(&n1, &n2);
	return 0;
}
// 포인터를 제거하여 매개 변수 둘 다 정수 값이라면(값에 의한 전달)
// 매개변수의 변경(num1, num2)은 실제 인자(n1, n2)의 값에 영향을 주지 않는다.
```
- 상수 포인터 전달하기: 데이터의 전달이 필요하지 않은 경우
- 포인터 반환하기 (함수로 메모리 개체를 반환할 필요가 있는 경우)
 - 함수 내에서 malloc으로 메모리를 할당한 후 함수 종료 시 반환한다. 이 함수를 호출한 호출자(caller)는 반환된 메모리를 해제할 책임이 있다.
 - 수정할 메모리 개체를 함수의 인자로 전달한다. 메모리 개체의 할당과 해제에 대하여 호출자에게 책임이 있다.
```c
int *allocateArray(int size, int value)
{
	int *arr = (int *)malloc(size * sizeof(int));

	int i = 0;
	while (i < size)
	{
		arr[i] = value;
		i++;
	}
	return arr;
}

int main()
{
	int *vector = allocate(5,45);
	for (int i = 0; i < 5; i++) 
	{
		printf("%d\n", vector[i]);
	}
	// 함수 실행 후 vector는 함수 내에서 할당된 메모리의 주소를 포함하고 있다.
	// 함수 종료되자 변수 arr은 사라졌지만, 포인터에 의해 참조된 메모리는 여전히 존재한다.

	// ...free(vector)
}
```
- 이 예제는 올바르게 작동하지만 함수로부터 포인터를 반환할 때 다음과 같은 몇가지 잠재적 문제가 발생할 가능성이 있다.
	- 초기화되지 않은 포인터의 반환
	- 잘못된 주소를 가리키는 포인터의 반환
	- 로컬 변수를 가리키는 포인터의 반환
	- 반환된 포인터의 메모리 해제 실패
- 로컬 데이터 포인터
	- 대안으로 변수 arr을 static으로 선언하는 방법이 있다. 이 방법은 변수의 범위는 함수로 제한되지만, 변수는 스텍 프레임 바깥에 할당되어 다른 함수가 변수의 값을 덮어쓸 가능성이 없어진다.
```c
int *allocateArray(int size, int value)
{
	static int arr[5];
	...
}
```
- NULL 포인터 전달하기
```c
int *allocateArray(int *arr, int size, int value)
{
	if (arr != NULL)
	{
		for (int i = 0; i < size; i++)
			arr[i] = value;
	}
	return arr;
}
//포인터가 함수로 전달될 때는 포인터를 사용하기 전에 널 여부를 검사하는 것이 좋다.
int *vector = (int *)malloc(5 * sizeof(int));
allocateArray(vector,5,45);
//만약 널 포인터가 전달되면 함수는 아무런 동작도 수행하지 않으며, 프로그램도 널 포인터에 의한 비정상 종료 없이 정상적으로 수행
```
- 포인터의 포인터 전달하기
	- 포인터가 함수로 전달되면, 포인터는 값에 의해 함수로 전달된다. 
	- 호출된 함수 내에서 포인터의 복사본에 대한 수정이 아닌 포인터 자체의 수정을 원한다면, 포인터의 포인터를 전달해야 한다.
	- 호출하는 함수에서 할당된 이 포인터를 수정하려면, 호출 시 포인터의 주소를 전달해야 한다. 따라서 함수의 매개변수는 정수에 대한
	포인터의 포인터로 선언되어 있고, 호출 함수는 포인터의 주소를 전달해야 한다.
```c
void allocateArray(int **arr, int size, int value)
{
	*arr = (int *)malloc(size * sizeof(int));
	if (*arr != NULL)
		for (int i = 0; i < size; i++)
			*(*arr + i) = value;
}

int *vector = NULL;
allocateArray(&vector, 5, 45);

==================

void allocateArray(int *arr, int size, int value)
{
	arr = (int *)malloc(size * sizeof(int));
	if (arr != NULL)
		for (i = 0; i < size; i++)
			arr[i] = value;
}
int *vector = NULL;
allocateArray(&vector,5,45);
printf(%p\n, vector);
// vector 변수가 함수로 전달 될 때 매개변수 arr로 복사되어 전달 되기 때문에 arr에 대한 변경은 vector에 전혀 영향을 미치지 않음.
```
- 사용자 정의 free함수 작성하기
```c
void safeFree(void **pp)
{
	if (pp != NULL && *pp != NULL)
	{
		free(*pp);
		*pp = NULL
	}
}
// free함수는 전달된 포인터가 NULL인지 검사하지 않으며, 할당 해제 후 반환시에 포인터를 NULL로 설정하지도 않는다.
// 메모리 해제 후 포인터를 NULL로 설정하는 것은 매우 좋은 습관이다.
```
- 함수 포인터: 함수의 주소를 가리키는 포인터다.
	- 함수 포인터는 어떠한 조건 문장도 사용하지 않고서 컴파일 시간에 미리 결정된 순서가 아닌 함수의 실행을 제어하는 방법을 제공한다.
	- 함수 포인터 사용에 한 가지 우려되는 점은 잠재적으로 프로갤므이 느리게 동작한다는 것이다 (프로세서는 파이프라이닝과 분기 예측을 함께 사용하지 못할 수 있다). 
	- 함수 포인터 이름 규칙에 항상 fptr 접두사 붙이는 방법 추천한다.
	- 함수 포인터 사용하기
```c
int (*fptr)(int);

int square(int num)
{
	return num * num;
}

int n = 5;
fptr1 = square;
printf("%d square is %d\n", fptr1(5));
}
// 함수의 실제 위치는 프로그램 스택과는 다른 세그먼트 영역에 할당되며, 일반적으로 관심의 대상이 아니다
```
- 함수 포인터 전달하기
```c
int add(int num1, int num2)
{
	return num1 + num2;
}

int sub(int num1, int num2)
{
	return num1 - num2;
}

typedef int (*fptrOperation)(int, int);

int compute(fptrOperation opertation, int num1, int num2)
{
	return operation(num1, num2);
}
```
- 함수 포인터 반환하기
```c
fptrOperation select(char opcode)
{
	switch(opcode)
	{
		case '+': return add;
		case '-': return subtract;
	}
}

int evaluate(char opcode, int num1, int num2)
{
	fptrOperation operation = select(opcode);
	return operation(num1, num2);
}

printf("%d\n", evaluate('+', 5, 6));
printf("%d\n", evaluate('-', 5, 6));
```
- 함수 포인터의 배열 이용하기
```c
typedef int (*operation)(int, int);
operation operation[128] = {NULL};
// 블록 안에 나열된 초기화 값의 수가 배열의 크기보다 작은 경우, 배열의 나머지 요소는 모두 0으로 초기화 된다
int (*operation[128])(int, int) = {NULL};
// 이 배열을 선언한 의도는 문자 인덱스를 사용하여 실행할 함수를 선택하기 위해서다.

void initializeOperationsArray()
{
	operation['+'] = add;
	operation['-'] = substract;
}

int evaluateArray(char opcode, int num1, int num2)
{
	fptrOperation operation;
	operation = operations[opcode];
	return operation(num1, num2);
}

initializeOperationsArray();
printf("%d\n", evaluateArray('+', 5, 6);
printf("%d\n", evaluateArray('-', 5, 6);
```
- 함수 포인터 비교하기
```c
fpterOpertaion fptr1 = add;

if (fptr == add)
{
	printf("add function\n");
else
{
	printf("not add function\n");
}
```
- 현실적인 예: 작업의 단계를 함수 포인터 배열로 표현하는 경우
	- 재고 부품의 배열을 조작하는 일련의 함수들이 있고, 이 함수로 구성된 두 가지 작업세트가 있다고 생각해보자.
	- 각 작업 세트는 개별 함수들에 대한 포인터들의 배열로 정의될 수 있고, 로그 작업은 두 작업 세트의 배열에 모두 존재할 수 있다.
	- 두 함수 포인터를 비교하는 기능을 사용하면 배열로부터 로깅 작업을 찾아서 삭제하거나 또 다른 함수를 찾아서 목록에서 제거하여 작업을 동적으로 변경할 수 있다.
	
- 함수 포인터 캐스팅
```c
typedef int (*fptrToSingleInt)(int);
typedef int (*fptrToTwoInts)(int, int);
int add(int, int);

fptrToTwoInts fptrFirst = add;
fptrToSingleInt fptrSecnod = (fptrToSingleInt)fptrFirst;
fptrFirst = (fptrToTwoInts)fptrSecond;
printf("%d\n", fptrFirst(5, 6));
```
- 함수 포인터와 데이터 포인터 사이의 변환은 동작하지 않을 수 있다.
```c
void *pv = add;
//할당 할 수 없다
// 함수 포인터를 교체하는 경우, 아래 선언된 기본 함수 포인터 타입을 참조하는 것이 일밙거이다.
typedef void (*fptrBase)();

fptrBase basePointer;
fptrFirst = add;
basePointer = (fptrToSingleInt)fptrFirst;
fptrFirst = (fptrToTwoInts)basePointer;
printf("%d\n", fptrFirst(5, 6));
```
- 항상 올바른 함수 포인터 인자 목록을 사용해야 하며, 그렇지 않은 경우 예상할 수 없는 동작이 발생한다.
- 상수 데이터를 포인터로 전달하는 방법은 함수에서 전달된 데이터의 수정을 막는 데 효과적이다.
- 포인터의 포인터를 전달하면 함수 내에서 인자로 전달된 포인터에 다른 메모리 영역을 할당하여 반환할 수 있다.

# Ch4. 포인터와 배열
- 유효하지 않은 배열의 인덱스를 이용했을 때의 동작은 예측할 수 없다. c언어에서는 범위를 강제하지 않는다.
- 배열에 할당된 주소는 바뀔 수 없지만, 포인터는 새 값을 할당받아 메모리의 다른 영역을 참조할 수 있다.
```c
int vector[5] = {1,2,3,4,5};
int *pv = vector;

pv = pv + 1;
vector = vector + 1; // 구문 오류
pv = vector + 1;
```
- malloc 함수로 1차원 배열 생성하기
	- 힙에서 메모리를 할당하고 그 주소에 포인터를 저장하면, 포인터에 배열 첨자를 이용하거나 메모리를 배열처럼 다루지 못할 이유가 없다.
```c
int *pv = (int *)malloc(5 * sizeof(int));
for (int i = 0; i < 5; i++)
	pv[i] = i + 1;

for (int i = 0; i < 5; i++)
	*(pv+i) = i + 1;
//*pv + i 참조 연산자가 +연산자 보다 우선순위가 높으므로 pv포인터가 역참조되어 포임터가 참조하는 값을 반환한다. 그 후에 1을 더하면 포인터가 참조하는 값에 1을 더하게 된다.
```
- realloc 함수로 배열 크기 조정하기
- C99 표준을 이용하지 않는다면, realloc 함수를 이용해야 할 것이다.
- 가변길이 배열은 함수 내에서만 선언할 수 있으므로 배열이 함수의 생명주기보다 더 오래 존재해야 한다면 realloc함수를 이용해야 한다.
- 1차원 배열이 함수로 전달되면, 배열의 주소가 값(by value)로 전달된다. 이렇게 하면 스택에 공간을 할당하여 전체 배열을 전달할 필요가 없으므로 더 효율적으로 정보를 전달할 수 있다. 이 경우 배열의 크기를 반드시 같이 전달해야 한다. 그렇지 않으면 함수의 입장에서는 크기를 모른 채로 배열의 주소만 알게 된다.
- 배열 요소의 실제 수보다 더 적은 수를 전달하는 것이 일반적이다. 만약 이러한 배열을 정렬하기 위해 sort함수를 호출한다면, 배열의 모든 요소가 아니라 유효한 값만 정렬해야 할 것이다.
- 포인터 표기법 사용하기
```c
void displayArray(int *arr, int size)
{
	for (int i = 0; i < size; i++)
		printf("%d\n", *(arr+i));
}
```
- 1차원 포인터 배열 이용하기
```c
int *arr[5];
for (int i = 0; i < 5; i++)
{
	arr[i] = (int *)malloc(sizeof(int));
	*arr[i] = i;
}
// arr이 포인터 배열로 선언되었기 때문에 arr[i]는 주소를 반환한다. 
// *arr[i]처럼 포인터를 역 참조하면 그 주소에 있는 내용을 가져올 수 있다.
*(arr+i) = (int *)malloc(sizeof(int));
**(arr+i) = i;
```
- 포인터와 다차원 배열
```c 
int matrix[2][5] = {{1,2,3,4,5}, {6,7,8,9,10}};
int (*pmatrix)[5] = matrix;
// 배열에 대한 포인터를 지정한다. 행당 다섯 개의 정수 요소를 가진 2차원 배열에 대한 포인터로 정의된다.
printf("%p\n", matrix); // 100
printf("%p\n", matrix + 1); // 120
printf("%d\n", sizeof(matrix[0]) // 20
```
- 다차원 배열 전달하기
	- 함수의 시그니처에 배열 표기법을 이용할 것인지 아니면 포인터 표기법을 이용할 것인지 선택해야 한다.
```c
void display2DArray(int arr[][5], int rows) {
void display2DArray(int (*arr)[5], int rows) {
// 두가지 버전 모두 행의 수는 지정되었다. 이는 컴파일러가 각 열의 요소 수에 대해 반드시 알아야 하기 때문이다.
// 다음과 같이 선언하면 제대로 동작하지 않는다. 함수는 전달된 배열이 다섯 개의 요소를 가진 정수에 대한 포인터의 배열일 것이라고 가정한다.
void display2DArray(int *arr[5], int rows) {
간단한 구현 방법
void display2DArray(int arr[][5], int rows) {
	for (int i = 0; i < rows; i++)
		for (int j = 0; j < 5; j++)
			printf("%d", arr[i][j]);
		puts("");
void main()
{
	int matrix[2][5] = {
		{1, 2, 3, 4, 5},
		{6, 7, 8, 9, 10}
	};
	display2DArray(matrix, 2);
}
// 이 함수는 배열에 메모리를 할당하지 않는다. 다만 주소만이 전달될 뿐이다.

void display2DArrayUnknownSize(int *arr, int rows, int cols)
{
	for (i = 0; i < rows; i++)
		for (int j = 0; j < cols; j++)
			printf("%d ", *(arr + (i * cols) + j));
}
// 이 함수는 다음과 같이 호출할 수 있다.
display2DArrayUnknownSize(&matrix[0][0], 2, 5); // &matrix[0][0]은 정수에 대한 포인터지만, matrix는 정수의 배열에 대한 포인터이다.
다음과 같이 배열 첨자를 이용할 수는 없다.
printf("%d ", arr[i][j]);
다음은 가능하다.
printf("%d ", (arr+i)[j]);
```
- 3차원 배열을 출력하는 함수
```c
void display3DArray(int (*arr)[2][4], int rows)
{
	for (int i = 0; i < rows; i++)
	{
		for (int j = 0; j < 2; j++)
		{
			printf("{");
			for(int k = 0; k < 4; k++)
				printf("%d ", arr[i][j][k]);
			printf("}");
		}
	}
}
// 이 함수 호출
int arr3d[3][2][4] = {
	...
};
display3DArray(arr3d, 3);
```
- 2차원 배열 동적으로 할당하기
	- 배열 요소가 인접해 있어야 하는지 
	- 배열이 가변이어야 하는지
	- 2차원 배열이 배열의 배열처럼 다루어질 수 있기에 '내부'의 배열이 반드시 인접할 필요는 없다.
	- 메모리가 인접해 있지 않으면 메모리 블록 등을 복사하는 등의 다른 동작에 영향을 줄 수 있다.
- 불연속 메모리 할당
```c
int rows = 2;
int columns = 5;

int **matrix = (int **)malloc(rows * sizeof(int *));

for (int i = 0; i < rows; i++)
	matrix[i] = (int *)malloc(columns * sizeof(int));
// 바깥쪽 배열에 메모리를 할당한 다음, 별도의 malloc함수를 이용해 각 열에 메모리 할당
```
- 인접한 메모리 할당
```c
int row = 2;
int columns = 5;
int **matrix = (int **)malloc(rows * sizeof(int *));
matrix[0] = (int *)malloc(rows * columns * sizeof(int));
for (int i = 1; i < rows; i++)
	maxtrix[i] = matrix[0] + i * columns;
// 한 번만에 대신 인덱스는 수동으로 계산해야 한다. 각 배열 요소는 그 인덱스의 곱으로 초기화한다.
int *matrix = (int *)malloc(rows * columns * sizeof(int));
```
- 가변 배열과 포인터
	- 가변 배열의 요소에 접근하기가 불편하다. C언어로 가변 배열을 만들 수 있지만, 그만한 가치가 있는가에 대해서 생각해 볼 필요가 있다.
```c
int (*(arr2[])) = {
	(int[]) {0,1,2,3},
	(int[]) {4,5},
	(int[]) {6,7,8}};

int row = 0;
for (int i = 0; i < 4; i++)
{
	printf(layer1[%d][%d] Address: %p Value: %d\n",
			row, i, &arr2[row][i], arr2[row][i]);
	//세 개의 for 루프가 필요하다.
```

# Ch5. 포인터와 문자열
- NULL과 NUL은 다르다. NUL은 문자이며 '\0'으로 정의한다. NULL은 ((void * )0)으로 정의한다.
- c언어에서 문자 상수는 정수(int)타입이다. sizeof(char)는 크기가 1이지만, sizeof('a')는 크기가 4가 될 것이다.
- 리터럴 문자열이 정의되면 종종 리터럴 풀에 할당된다. 이 메모리 영역은 문자열을 구성하는 문자 배열을 저장한다. 리터럴 문자열이 한 번 이상 사용되면, 일반적으로는 하나의 복사본만이 리터럴 풀에 존재한다. 이렇게 하면 메모리 공간을 절약할 수 있다. 하지만 언제나 하나의 복사본만 존재하거나 리터럴이 변경할 수 없다고 가정하는 것은 좋지 않은 습관이다. 컴파일러 대부분은 풀링 기능을 끌 수 있는 옵션을 제공한다.
- 문자열 리터럴은 종종 읽기 전용 메모리에 할당되어 변경할 수 없다.문자열 리터럴이 어느 위치에서 사용되는지, 또는 변수 범위가 전역인지 로컬인지 상관 없다. 이런 측면에서 문자열 리터럴은 범위를 갖지 않는다.
- char 배열 초기화
```c
char header[] = "Media Player";

header[0] = 'M';
...
// 다음 할당은 유효하지 않다. 문자열 리터를의 주소를 배열 변수의 이름에 할당할 수 없다.
char header2[];
header2 = "Media Player"
```
- char 포인터 초기화하기
```c
char *header = (char *)malloc(strlen("Media Player")+1);
strcpy(header, "Media Player");
```
- malloc 함수에 전달할 문자열의 길이를 결정할 때는 아래 사항에 유의한다.
	- NUL문자를 위해 1바이트를 추가로 할당
	- sizeof 연산자는 배일이나 포인터의 크기를 반환하므로 strlen 함수를 이용
- 문자열 리터럴 주소를 아래 코드처럼 char 포인터에 직접 할당할 수 있다. 단, 문자열의 새로운 복사본을 생성하지 않음. (힙에 없음, 문자열 리터럴 풀) char * header = "Media Player";
- char 포인터는 문자 상수로 초기화 할 수 없다. char포인터에 정수를 할당하려는 시도와 같다.
```c
char *prefix = '+' // 유효하지 않음
// malloc 함수 사용
prefix = (char *)malloc(2);
*prefix = '+';
*(prefix+1) = 0;
```
- 표준 입력(stdin)으로 문자열 초기화하기
```c
char *command;
scanf("%s", command");
// 문자열을 입력받을 때 잠재적인 초기화 오류가 발생할 수 있다. command변수를 사용하기 전 메모리를 할당하지 않았기 때문이다.
// 포인터에 메모리를 할당하거나 포인터 대신 고정 크기 배열을 사용해야 한다.
```
- 문자열 위치 요약(p151. 그림 완벽히 이해할 것!)
- 부정확한 비교는 틀리거나 유효하지 않은 결과를 유도할 수 있다.
```c
int strcmp(const char *s1, const char *s2)
// 음수 - s1이 s2보다 사전적으로 앞에 있을 때, 0 - 두 문자열 동일, 양수 - s1이 s2보다 사전적으로 뒤에 있을 때

char command[16];
scanf("%s", command);
if (strcmp(command, "Quit") == 0)
	printf("The command was Quit");
else
	printf("The command was not Quit.");

// 문자열을 비교할 때 잘못된 2가지 케이스
1
scanf("%s", command);
if (command == "Quit")
... // 문자열 상수의 주소를 배열 이름에 할당할 수 없다. command변수가 배열이니 배열 첨자를 이용하지 않고 값을 할당하는 건 불가능하다.

2
if (command == "Quit") // 변수의 주소와 문자열 상수의 주소를 비교하기에 false로 평가된다.
```
- 일반적인 애플리케이션은 다수의 문자열을 입력받아 각각의 문자열을 최소한의 메모리를 사용하여 배열에 저장한다.
	1. 문자열을 읽어 들여 큰 char 배열에 저장한다.
	2. malloc함수를 이용해 딱 맞는 크기의 메모리를 할당한다.
	3. strcpy함수를 이용해 동적으로 할당된 메모리에 문자열을 복사한다.
```c
char name[32];
char *names[30];
size_t count = 0;

scanf("%s", name);
names[count] = (char *)malloc(strlen(name)+1);
strcpy(names[count], name);
count++;
```
- 두 개의 포인터가 같은 문자열을 참조할 수 있다. 이를 에일리어싱(aliasing)이라고 부른다. 하나의 포인터를 다른 포인터에 할당한다고 하여 문자열이 복사되는 것은 아니라는 점을 알아두어야 한다. 이는 단순히 문자열의 주소를 복사한 것 뿐이다.
```c
char *pageHeaders[300];

pageHeaders[12] = "Amorphous compounds";
pageHeaders[13] = pageHeaders[12];
// 두개의 포인터는 모두 같은 리터럴 문자열을 참조. 포인터는 복사되었지만 문자열은 복사되지 않는다.
```
- 문자열 연결
```c
char *strcat(char *s1, const char *s2);
// 이 함수는 메모리를 추가로 할당하지 않는다. 첫번째 문자열이 연결된 문자열을 포함할 수 있을 만큼 충분한 메모리 할당되어야 한다.
char *error = "ERROR: ";
char *errorMessage = "Not enough memory";

char *buffer = (char *)malloc(strlen(error)+strlen(errorMessage)+1);
strcpy(buffer, error);
strcat(buffer, errorMessage);
//ERROR: Not enough memory
```
- Segmentation error 발생함.

- 리터럴 문자(상수)' ', 리터열 문자열 " ", 문자열을 연결할 때는 리터럴 문자열을 사용한다. 리터럴 문자로 사용하면 char의 주소로 해석되어 런타임 오류 발생한다.
- 함수 외부에서 버퍼를 전달할 때는 다음 사항을 고려해야 한다.
	- 버퍼의 주소와 크기를 반드시 전달해야 한다.
	- 함수를 호출하는 쪽에서 버퍼를 해제해야 한다.
	- 함수는 일반적으로 전달된 버퍼에 대한 포인터를 반환한다.
- 버퍼의 할당과 해제에 대한 책임이 함수를 호출하는 쪽
- 애플리케이션 인자 전달하기
	- 실행 인자(argc)는 몇 개의 실행 인자가 전달되었는지를 알려주는 정수이다. 실팽 파일의 이름은 항상 전달된다.
	- 매개 변수(argv)는 대개 문자열 포인터에 대한 1차원 배열로 다루어진다.
- 유효한 문자열의 주소 반환
	- 리터럴 문자열
	- 동적으로 할당된 메모리
	- 로컬 문자열 변수
- 반환된 메모리는 함수를 호출한 쪽에서 해제해야 한다.
- 문자열이 printf 함수 안에서 사용되었고, 변수에 따로 저장되지 않았기에 그 주소가 분실된다.
- 로컬 문자열 주소 반환하는 것은 해당 메모리가 나중에 다른 스택 프레임에 의해 덮어 쓰여 변조될 수 있기에 문제가 된다.
	- 함수는 배열의 주소를 반환, 메인함수에서 blank함수 호출하면 다음에 호출되는 함수에 의해 덮여쓰인다

# Ch6. 포인터와 구조체
- 구조체에 대한 포인터를 이용하면 ->(points-to)연산자를 이용해야 한다.
- 포인터를 역참조한 후 .(dot) 기호를 이용할 수도 있다.
```c
Person *ptrPerson;
ptrPerson = (Person *)malloc(sizeof(Person));
ptrPerson->firstName = (char *)malloc(strlen("Emily") + 1);
// (*ptrPerson).firstName = (char *)malloc(strlen("Emily") + 1);
strcpy(ptrPerson->firstName, "Emily)
//strcpy((*ptrPerson).firstName, "Emily");
ptrPerson->age = 23;
// (*ptrPerson).age = 23;
```
- 구조체의 각 변수 사이에 패딩(padding)이 발생하기에 종종 필드 크기의 합보다 더 많은 크기가 할당된다. 패딩은 데이터 타입을 특정한 범위 안에 정렬하기 위해 이용된다.
	- 포인터 연산이 주의 깊에 이루어져야 한다.
	- 구조체를 요소로 가진 배열은 각 요소 사이에 추가적인 메모리가 할당되어 있을 수 있다.
- 구조체에 메모리가 할당될 때, 런타임 시스템은 구조체 내부에 선언된 포인터에 자동으로 메모리를 할당하지 않는다. 같은 이치로, 구조체가 삭제될 때도 런타임 시스템은 구조체 내부의 포인터에 할당된 메모리를 자동으로 해제 하지 않는다.
- 타입의 변수를 선언하거나 메모리를 동적으로 할당할 때, 구조체 내부의 세 포인터는 가비지(garbage)값을 가진다. 하지만 선언한 구조체 변수가 정적인 저장 공간에 할당되면 구조체의 멤버는 모두 0으로 초기화된다.
- person 변수의 선언이 함수의 일부분이기 때문에, 함수가 반환할 때 person에 할당된 메모리도 해제된다. 하지만 동적으로 할당된 문자열은 해제되지 않고 힙에 남아있다. 불행히도 우리는 그 주소를 알지 못하기 때문에 해제할 수 없고 메모리 누수가 발생한다.
- 구조체가 반복적으로 할당되고 해제될 때 특정한 오버헤드가 발생하게 되고, 결국 성능에 중대한 저하를 가져오게 된다. 이 문제를 해결하는 한가지 방법은 자신만의 할당된 구조체 목록을 따로 관리하는 것이다. 구초제의 개체가 더는 필요하지 않을 때 풀에 반환한다. 필요하면 풀에서 객체를 얻는다.
- 포인터는 복잡한 데이터 구조도 유연하게 지원한다. 이 유연함은 동적인 메모리 할당과 포인터 참조 변경의 용이성으로부터 기인한다. 메모리는 배열처럼 인접해 있을 필요도 없다. 딱 필요한 만큼의 메모리만 할당하면 된다.
- 단일 연결 리스트
	- 배열을 이용하면, 얼마나 많은 노드가 필요하냐와 상관없이 고정된 수의 노드를 생성해야 한다.
	- 노드간의 링크는 배열의 요소를 이용해 구현한다.
	- 동적 메모리 할당과 포인터를 사용하는 방법보다 유연성이 부족하다.
	- 예를 들어, 배열 요소의 순서를 바꿀려면 요소를 모두 복사해야 하는데 복사되는 데이터 구조가 매우 클 수도 있다. 요소를 추가하거나 삭제할 때 여유 공간을 만들기 위해 대량의 요소를 이동시켜야 할 수도 있다.
- 단일 연결 리스트: head 노드에서 tail 노드까지 연결된다.
- 환형(circular) 연결 리스트: tail노드가 없다. 마지막 링크는 다시 리스트의 head 노드를 가리킨다.
- 이중 연결 리스트(doubly linked list): 두 개의 링크를 이용해 리스트를 양쪽으로 탐색할 수 있다.
- 사용자는 Delete함수를 호출하기 전에 이 노드가 가리키는 데이터를 삭제해야 한다.
- 이진 검색 트리의 일반적인 정렬 방법은 왼쪽에 있는 자식 노드가 부모 노드보다 작은 값을 갖고, 오른쪽에 있는 자식 노드가 부모 노드보다 큰 값을 갖는다.
- 포인터의 강력함과 유연함은 데이터 구조의 생성과 지원에 사용될 때 잘 드러난다. 구조체의 동적인 메모리 할당과 함께 활용하면 메모리를 효율적으로 사용하며, 동적으로 줄어들거나 늘어나는 데이터 구조를 만들 수 있다.

# Ch7. 보안 이슈와 포인터의 오남용
- C로 안전한 애플리케이션을 작성하는 것은 언어에 고유한 몇 가지 속성 때문에 쉽지 않다. (C는 프로그래머가 배열의 영역을 넘어선 영역에 데이터를 기록하는 것을 막지 않는다. 이러한 접근은 메모리 손상되어 잠재적인 취약점이 될 수 있다. 또한, 포인터의 부적절한 사용은 많은 보안 문제의 근본적인 원인이 되기도 한다)
- 주소 영역 배치 랜덤화(Address Space Layout Randomization): 메모리 내 애플리케이션의 데이터 영역을 랜덤하게 배치한다. 데이터 영역은 코드, 스택, 힙을 포함한다. 이 영역의 배치를 랜덤화하면 공격자가 메모리가 어디에 위치할지 예측하기 어려우므로 데이터 영역에 접근하기 힘들다. (스택과 libc의 위치가 알려지지 않는다면 이런 공격은 성공하기 어렵다)
- 데이터 실행 방지(DEF) 기법은 코드가 메모리의 실행 불가능한 영역에 있을 때 실행을 차단한다. 몇몇 종류의 공격은 메모리의 영역을 악성 코드로 덮어쓴 후 제어를 이 영역으로 넘긴다.
- 부적절한 포인터 선언
```c
int *ptr1, ptr2;
// 개발자가 의도한 바와 다를 가능성이 높다. 하나는 int *, 하나는 int형 타입으로 선언되었다. 이 코드를 읽는 사람에겐 둘다 int * 형식으로 선언했다는 느낌을 준다.
int *ptr1, *ptr2; 
// 각 변수를 다른 줄에 선언하는 습관을 드이는 것이 훨씬 더 낫다.
```
```c
#define PINT int*
PINT ptr1, ptr2 
// 앞에서 설명한 문제가 똑같이 발생

typedef int* PINT;
PINT ptr1, ptr2
```
- 초기화되지 않은 포인터(와일드 포인터, wild pointer)
	- 포인터를 초기화하기 전에 사용하면 런타임 에러가 발생할 수도 있다. 
- 초기화 되지 않은 포인터를 다루는 3가지 방법
	- 포인터는 언제나 NULL로 초기화한다 (뭔가 지루하다. if (pi == NULL) 역참조x else 내용)
	- assert 함수를 활용한다(디버그용 버전, assert(pi != NULL); // Assertion failed pi != NULL)
	- 서드파티 도구를 활용한다.
- 많은 보안 이슈의 중심적인 개념은 버퍼 오버플로(buffer overflow)다. 버퍼 오버플로는 객체의 영억을 벗어난 영역의 메모리가 덮어 쓰일 때 발생한다. 운영체제 세그멘테이션 폴트 발생시키고 강제로 프로그램 종료. 고의로 행해졌을 경우 서비스 거부 공격으로 간주. 이런 종류의 공격은 인가되지 않은 권한을 얻으려는 것이 아니라 실행을 방해한다. 버퍼 오버플로가 애플리케이션 내 다른 주소 공간 내 발생하면 데이터에 대해 허가되지 않은 접근이 발생하거나 코드의 다른 세그먼트로 제어가 넘어가 시스템을 파괴한다.
- 다음과 같은 원인으로 발생한다.
	- 배열 요소에 접근할 때 사용하는 인덱스의 값을 확인하지 않음
	- 배열 포인터에 대한 포인터 연산을 할 때 주의를 기울이지 않음
	- 표준 입력(stdin)에서 문자열을 읽어 들일 때 gets 같은 함수를 사용함
	- strcpy나 strcat같은 함수를 부적절하게 사용함
- malloc 부류의 함수를 사용할 때는 언제나 반환 값을 확인해야 한다. 반환 값을 확인하지 않으면 프로그램이 비정상적으로 종료될 수 있다.
```c
float *vector = malloc(20 * sizeof(float));
if (vector == NULL)
	malloc 함수 메모리 할당 실패
else
	vector 를 여기서 처리
```
- 역참조 연산자의 잘못된 사용
```
int num;
int *pi = &num;

int num;
int *pi;
*pi = &num; // num변수의 주소를 pi포인터에 할당하는 것이 아니라 pi에 의해 지정된 메모리 영역에 할당하려고 한다. pi 포인터는 초기화되지 않음.
int num;
int *pi;
pi = &num;
```
- 댕글링 포인터
	- 해제 된 이후 이 메모리 영역에 접근하려면 그 메모리의 내용이 변경되었을 수 있다. write연산을 실행하면 메모리가 손상될 수 있고, read연산을 실행하면 유효하지 않은 데이터가 반환될 수 있다.
- 프로그램이 배열에 할당된 범위를 벗어난 메모리 영역에 접근하는 것을 막을 방법이 없다.
- strcpy와 같이 버퍼의 크기를 같이 전달할 수 없는 함수는 주의해서 사용해야 한다.
- sizeof 연산자 오용
	- sizeof(buffer) / sizeof(int)를 이용하자. sizeof(buffer)는 각 요소는 4바이트 * 20 이기에 루프가 4배 더 실행된다.
- 언제나 데이터 타입에 대한 적절한 포인터 타입을 사용하는 것이 좋다. (int 최대수, short로 형변환 시 -1로 된다.)
- 유계 포인터(bounded pointers)
	- 유효한 영역 내에서만 사용이 가능한 포인터를 의미한다.
	- 개발자가 명시적으로 포인터의 범위를 제한할 수 있지만 귀찮을 수 있다.
- 문자열 보안 이슈
	- stcpy나 strcat 같은 문자열 함수는 주의 깊게 사용하지 않으면 버퍼 오버플로가 발생할 수 있다. (size_t 매개변수를 통해 복사 문자 최대수를 지정함으로써 버퍼 오버플로를 방지한다)
- 포인터 연산과 구조체
	- 포인터 연산은 배열에만 이용할 수 있다. 배열은 연속된 메모리 블록이 할당됨을 보장하므로, 포인터 연산의 결과가 유효한 오프셋안에 있게 된다. 하지만 구조체에서는 포인터 연산을 사용하지 않아야 한다. 구조체의 각 필드가 연속된 메모리 영역에 할당되지 않을 수 있기 때문이다.
- 세 개의 정수로 구성된 구조체, 일반적으로 세 정수 필드가 연속된 메모리 공간에 할당되긴 하지만, 항상 그렇다고 보장할 수 없다.
	- 포인터 연산을 통해 Item타입의 part변수, 필드에 접근할 수 있다. 하지만 항상 그렇다고 보장할 수 없다.
	- 각 필드를 다른 포인터에 할당하는 것이다.
	- 아예 포인터를 사용하지 않는 방법이 제일 좋다.
- 함수 포인터 이슈(함수와 함수 포인터는 프로그램의 실행 순서를 제어하기 위해 사용된다)
	- 시스템의 상태를 정수로 반영하는 함수가 있다고 해보자. 괄호를 여닫는 걸 생략한다면 문제가 발생. 함수가 그 이름자체로 사용되면 그 주소가 반환되는 것이다.
- 함수를 시그니처(매개변수의 타입, 개수 반환 값 타입 등 함수의 고유한 형태)가 다른 함수 포인터에 할당하지 않도록 한다.
	- 동작은 정의되어 있지 않아 실행결과를 예측할 수 없다.
	- 공격자가 버퍼 오버플로를 이용해 함수 포인터의 주소를 덮어쓸 수 있따. 그렇게 되면 제어가 메모리의 임의 위치로 옮겨진다.
- 메모리 해제 이슈
	- 이중 해제: 똑같은 메모리 블록을 두 번 해제하는 것을 말한다.
	- 이런 취약점을 회피하는 간단한 기법은 메모리를 해제하면 항상 포인터에 NULL을 할당하는 것이다.
	- 민감한 데이터 지우기: 저장된 영역이 더는 필요하지 않으면 이 영역을 덮어쓰는 것이 좋다.
```c
char name[32];
int userID;
char *securityQuesttion;

memset(name, 0, sizeof(name));
userID = 0;
memset(securityQuestion, 0, strlen(securityQuestion));

//name 변수가 포인터로 선언되었다면 메모리 해제 전 초기화
char *name = (char *)malloc...
...
memset(name, 0, sizeof(name));
free(name);
```

# Ch8. 기타
- 스레드에 대한 두 가지 흥미로운 영역이 있다. 첫 번째는 포인터를 이용해서 다수의 스레드  간 데이터를 공유하는 기본적인 문제에 대한 것이다. 두 번째는 콜백(callback)에서 포인터가 어떻게 사용되는지에 대한 것이다. 콜백함수 란 어떤 작업을 위해 함수가 호출될 때 실제 호출되는 함수가 변경될 수 있으면 이를 콜백 함수라 한다.
- C에서 객체 지향 타입을 지원할 수 있는 2가지 방법, 첫째는 불투명(opque)포인터를 이용하는 법이다. 이 기법은 사용자에게 데이터 구조의 세부 구현을 감춘다. 두번째 방법은 C에서 다형성 타입(polymorphic type)같은 방식을 어떻게 구현하는지 보여줄 것이다.
- 포인터 캐스팅
	- 특수 목적 주소에 접근할 수 있다
	- 포트에 대응하는 주소를 할당할 수 있다
	- 시스템의 엔디안 타입을 알 수 있다
```c
int num = 8;
int *pi = (int *)num;
// 정수를 정수포인터로 캐스팅할 수 있다. 단, 이 예제는 접근 권한이 없는 임의의 메모리 주소에 접근할 수 있도록 허용하기에 적절하지 않은 예제다.
```
```c
pi = &num;
printf("Before: %p\n", pi);
int tmp = (int)pi;
pi = (int *)tmp;
printf("After: %p\n", pi);
// 포인터를 정수로 캐스팅하고 다시 포인터로 캐스팅하는 것은 절대로 좋은 방법이 아니다. 만약 그렇게 해야만 한다면, 유니언을 사용을 고려하자. 포인터를 void로 캐스팅하거나 void를 포인터로 캐스팅하는 것과는 다르다.
```
- 포트에 접근하기
	- 포트는 하드웨어적인 개념과 소프트웨어적인 개념을 모두 가지고 있다. 서버는 컴퓨터로 전달된 특정한 메시지를 자신이 받는다는 것을 알리기 위해 소프트웨어 포트를 이용한다. 하트웨어 포트는 일반적으로 외부 장치에 연결된 물리적인 입출력 시스템 컴포넌트이다.
- 컴파일러는 때로 최저고하를 위해 캐시나 레지스터에 메모리의 값을 임시로 저장하기도 한다. 만약 외부 장치의 쓰기 연산이 메모리의 값을 바꾸게 되면, 이 값이 캐시나 레지스터에 저장된 값에는 반영되지 않는다.
- volatile 키워드를 사용하면 런타임 시스템이 레지스터에 임시로 포트의 값을 저장하지 못하도록 한다.
- 직접메모리 접근(Direct Memory Access, DMA)은 메인 메모리와 특정 장치 간 데이터 전송을 보조하는 저수준 동작이다. 프로그래머는 DMA함수를 호출하고 동작이 끝날 때 까지 대기한다. 종종 프로그래머가 콜백 함수를 제공하기도 한다. 동작이 끝나면 운영체제에 의해 콜백 함수가 호출된다.
- 두 포인토거 같은 메모리 위치를 참조한다면, 한 포인터를 다른 포인터에 대한 에일리어스(alias)라고 부른다. 이러한 경우가 일반적이지 않으며 많은 문제를 발생시킨다.
	- 컴파일러가 그 메모리 위치에서 데이터를 읽거나 쓰는 코드를 생성할 때, 메모리의 위치 값을 레지스터에 저장하게 함으로써 코드를 최적화하는 것이 불가능할 수도 있다.
- 엄격한 에일리어싱은 한 데이터 타입에 대한 포인터가 타입이 다른 포인터에 대해 에일리어싱하는 것을 허용하지 않는다.
- 에일리어싱 문제를 회피하는 방법
	- 유니언을 사용한다.
	- 엄격한 에일리어싱을 비활성화 한다.
	- char * 를 사용한다.
- 어떤 데이터 타입의 포인터를 문자 포인터로 캐스팅하고 나서 문자 포인터를 다시 두 번째 데이터 타입으로 캐스팅하는 것은 정의되지 않은 행동이므로 피해야 한다.
- 구조체의 정의가 같고 이름만 다른 경우 다수 포인터가 하나의 객체를 참조할 수 있다.
- C 컴파일러는 포인터가 기본적으로 에일리어스되었다고 가정한다. 포인터를 선언할 때 restrict 키워드를 이용해 컴파일러에 해당 포인터가 에일리어스되지 않음을 알릴 수 있다.
	- 컴파일러에게 restrict 키워드는 특정한 코드 최적화를 수행할 수 있음을 알리는 신호이다.
	- 프로그래머에게 이 포인터가 절대 에일리어스되지 말아야 하며, 에일리어스되었을 경우 그 결과는 정의되어 있지 않음을 알려주는 신호이다.
- 스레드와 포인터
	- 다수의 스레드가 데이터를 공유하면, 많은 문제가 발생할 수 있다. 가장 흔한 문제는 데이터의 손상이다.
	- mutex를 이용해 보호하는 변수를 한 번에 한 스레드만의 접근을 허용하게 한다. mutex는 다수의 스레드가 접근할 수 있도록 전역 수준에서 사용한다.
- 좀더 일반적인 콜백함수의 정의는 한 스레드에서 발생한 이벤트로 인해 다른 스레드의 함수가 실해오디는 것이다. 먼저, 한 스레드에 콜백 함수의 함수 포인터가 전달된다. 그리고 함수 내에서 이벤트가 발생하면 콜백 함수를 호출한다.
- C 언어에서 효과적인 데이터 캡슐화에 불투명 포인터를 이용할 수 있다. 한 가지 접근 방식은 어떤 구현도 없는 구조체를 헤더 파일에 선언하는 것이다. 함수는 그 이후 데이터 구조의 구현에 따라 동작하도록 구현 파일에 선언된다. 데이터 구조 사용자는 함수의 선언과 프로토타입을 보게 되지만, 실제 구현은 .c/.obj파일 안에 숨겨진다.
- 사용자가 연결 리스트의 내부 구조에 대해 알거나 더 나아가서 내부 구조를 사용하는 것은 제한되어 있다. 구조체에 대한 어떤 변경도 사용자로부터 은닉된다.
- 사용자는 연결 리스트에 대한 네 가지 함수의 시그니처만 알 수 있다. 그 외에는 사용자가 연결 리스트의 내부 구현에 대한 정보를 이용한다거나 구현 자체를 변경할 수 없다.
- C언어는 상속을 지원하지 않기 때문에 구조체 간의 상속을 가상으로 구현해야 한다.
