# 지은이의 글
포인터는 메모리를 동적으로 다룰 수 있는 메커니즘을 제공하고, 데이터 구조를 더 강력하게 지원하며, 하드웨어에 대한 접근을 가능하게 한다. 포인터의 이런 강력함과 유연함을 공짜로 얻을 수는 없다. 포인터를 완벽하게 마스터 하는 것은 결코 쉬운 일이 아니다.

# Ch1. 시작하기
포인터를 이해하는 열쇠는 C 프로그램에서 메모리가 어떻게 관리되는지 이해하는 데 있다. 결국, 포인터는 메모리의 주소를 담고 있기 때문이다.

- 접근 범위(Scope)와 수명(Lifetime)

||접근범위|수명|
|:----:|:----:|:----:|
|전역|전체파일|애플리케이션 실행 동안 유지|
|정적|선언된 함수|애플리케이션 실행 동안 유지|
|자동(로컬)|선언된 함수|함수 실행 동안 유지|
|동적|참조하는 포인터|메모리 해제 전까지 유지|

- 배열 연결 리스트 vs 포인터 연결 리스트
	- 배열을 사용하여 데이터 구조를 구현할 경우 포인터의 역활을 배열의 인덱스로 대체할 수 있지만, 포인터만큼 직관적이거나 유연하지 못하다.
	- 배열의 크기는 일반적으로 배열이 생성될 때 결정되어 배열이 저장할 수 있는 요소의 수에 제약이 발생한다. 포인터를 사용하면 이러한 제약이 없으며, 새로운 노드가 필요할 때 동적으로 할당할 수 있다.

- 포인터를 초기화하지 않고 사용할 수 있지만, 초기화하기 전까지는 제대로 동작하지 않을 것이다(메모리는 할당될 때 초기화 되지 않기에 이전에 사용된 데이터가 메모리에 존재한다).
- 포인터 선언을 뒤에서 읽음으로써 선언을 점차적으로 이해할 수 있다.
	- 상수 정수를 가리키는 포인터 변수 pci : const int * pci;
- 포인터는 가능한 한 빨리 초기화하는 것이 위와 같은 잘못된 포인터의 사용을 피할 수 있는 좋은 습관이다.
```c
int num;
int *pi = &num;
```
- 널 포인터와 초기화되지 않은 포인터는 명백히 다르다. NULL을 포함한 포인터는 메모리상의 어떤 위치도 참조하지 않지만, 초기화되지 않은 포인터는 어떤 값이라도 포함될 수 있으며 참조될 수 있다.
- 널 포인터가 포함한 주소는 유효한 주소가 아니므로 절대 역참조해서는 안 되며, 널 포인터에 대한 역참조는 프로그램의 비정상 종료를 초래한다.
- 그러나 NULL은 포인터가 아닌 상황에서는 사용하지 말아야 한다. NUL 아스키 문자는 문자 리터럴 '\0'과 같은 뜻이며, 십진수 값 0을 의미한다.
- 포인터의 크기를 알 필요가 있을 때 항상 sizeof 연산자를 사용하도록 하자.

- 포인터 연산자
	- * : 포인터 선언
	- * : 역참조, 포인터 역참조
	- -> : 포인터, 포인터로 참조된 구조체의 멤버 접근
	- + : 더하기, 포인터 증가
	- - : 빼기, 포인터 감소
	- == != : 같음, 같지 않음, 두 포인터의 비교
	- (데이터 타입) : 캐스팅, 포인터 타입 변환
- 포인터는 상수를 가리키도록 정의될 수 있다. 이 말은 곧 포인터는 포인터가 참조하는 값을 수정하는 데 사용될 수 없음을 의미한다.
	- 상수 정수 포인터 (const int * pci)
	- 상수 정수 선언시 const와 type의 순서는 중요하지 않다.
	- pci는 다른 상수 정수를 가리키거나 비상수 정수를 가리키도록 할당될 수 있다. 역참조도 가능하다 (pci = &num) 
	- 단, * pci = 바꿀 값 은 불가하다. (pci 포인터가 가리키는 것이 num 변수 일때도, pci 포인터는 자신이 상수 정수를 가리키고 있다고 판단)
```c
int num;
int *const cpi = &num;
```
- cpi 변수는 비상수 변수로 초기화 되어야 한다.
- cpi 변수는 변경될 수 없다.
- cpi 포인터 변수가 가리키는 변수의 값은 변경할 수 있다.
- 가능
	- * cpi = limit;
	- * cpi = 25;
- 경고 (cpi는 상수 limit을 가리키고 있지만, 상수 limit은 cpi 포인터에 의해 변경될 수 있다)
	- const int limit = 500;
	- int * const cpi = &limit;
- 불가 
	- cpi = &age; 

- 상수를 가리키는 상수포인터
	- 이는 변수의 선언과 동시에 초기화해야 한다.
	- 포인터 데이터의 변경과 포인터에 의해 가리켜진 데이터의 변경이 불가하다.
```c
const int *const cpci = &limit;
//불가 cpci = &num
//불가 *cpci = 25;
```
- 다중 상수 포인터
```c 
const int limit = 500;
const int *const cpci = &limit;
const int *const *pcpi = &cpci;
```
       						포인터 데이터 변경, 포인터 대상 데이터 변경
비상수를 가리키는 포인터  			O		  , 		O
상수를 가리키는 포인터 				O		  , 		X
비상수를 가리키는 상수 포인터  		X		  ,  		X
상수를 가리키는 상수 포인터			X		  , 		X

# Ch2. 동적 메모리 관리
- 포인터의  강력한 기능의 대부분은 동적으로 할당된 메모리를 추적할 수 있는 포인터의 능력에서 기인한다.
- C프로그램은 런타임 시스템(runtime system)안에서 실행된다. 런타임 시스템은 일반적으로 운영체제에서 제공되는 환경이며, 많은 프로그램 기능들과 함께 스택(stack)과 힙(heap)을 지원한다.
cf. 주기억장치를 효율적으로 운영하기 위해서 일정한 크기, 논리적 단위로 나누어서 할당과 할당 해제로 관리하게 된다. 그 논리적 단위를 세그먼트(Segment)라고 하고, 서로 관련이 있는 데이터와 명령어를 하나의 세그먼트로 관리하는 것이 아니라 데이터를 저장하는 데이터 세그먼트(data segment)영역과 명령어를 저장하는 코드 세그먼트(code segment)영역으로 구분해서 사용한다.
- 데이터 세그먼트는 실행 코드와 런타임 시스템에 의해 관리되는 다른 데이터와는 분리된 영역이다.
- C와 같은 언어들은 힙(Heap)에서 메모리를 할당하는 동적 메모리 관리를 지원한다. 동적 메모리 할당은 할당, 해제 함수를 사용하여 수동으로 처리된다. 이를 동적 메모리 관리(dynamic memory management)라고 한다.
- 역참조 연산 시 가장 흔하게 발생하는 오류
```c
int *pi;
*pi = (int *)malloc(sizeof(int));
// pi 정수 포인터에 아직 메모리가 할당되지 않은 상태라면, pi포인터에는 유효하지 않은 값이 포함되어 있다. 그래서 아래와 같이 접근해야 한다.
pi = (int *)malloc(sizeof(int));
```
- 메모리가 할당되면 추가적인 정보가 힙 관리자에 의해 관리되는 데이터 구조의 일부로 저장된다. 
- 메모리 누수
	- 메모리의 주소를 잃어버리는 경우
	- free 함수가 호출되어야 하는 상황에 호출되지 않은 경우
	- 메모리 누수의 문제점은 해당 메모리가 반환되지 않고 다시 사용될 수 없다는 것이다. 그 결과 힙 관리자가 사용할 수 있는 메모리의 양이 감소한다.
```c
char *chunk
while (1)
{
	chunk = (char *)malloc(100000);
	printf("Aloocating\n");
}

// 메모리 주소 손실 -> 메모리 주소가 해제 되지 않은 상태이며, 프로그램 어디에서도 이 주소를 알지 못함.
int *pi = (int *)malloc(sizeof(int));
*pi = 5;
...
pi = (int *)malloc(sizeof(int));

// 메모리 시작 주소 잃어버림
char *name = (char *)malloc(strlen("junto")+1);
strcpy(name, "junto");
while (*name != 0)
{
	printf("%c", *name);
	name++;
}
```
- 메모리 주소 손실
- 숨겨진 메모리 누수
	- 할당된 메모리가 더는 필요하지 않은 순간에도 힙에 유지 될 때 발생한다.
	- 큰 문제점은 더는 필요하지 않으며, 반환될 필요가 있는 메모리를 계속 붙잡고 있다는 것이다.
	
- 동적 메모리 할당 함수
	- malloc : 힙에서 메모리 할당
	- calloc : 힙에서 메모리 할당 그리고 0으로 설정
	- realloc : 기존 할당된 메모리의 크기 변경
	- free : 할당된 메모리를 힙으로 반환
- 반복적인 메모리 할당 호출은 할당된 메모리의 순서나 연속성에 대해 보장해주지 않는다.
- 그러나 할당된 메모리는 포인터의 데이터 타입에 따라 정렬된다.
- malloc 함수
	- 프로토타입 : void * malloc(size_t);
	- 일반적으로 다음과 같이 사용한다.
	int *pi = (int *)malloc(sizeof(int));
	- malloc 함수가 호출되면 아래 단계가 수행된다.
		- 힙 영역에서 메모리가 할당된다.
		- 메모리는 수정되거나 초기화되지 않는다.
		- 첫 번째 시작 주소가 반환된다.
		malloc 함수는 메모리 할당할 수 없을 때 NULL을 반환하기에 반환 주소를 사용하기 전에 검사하는 것이 좋다.
		int *pi = (int *)malloc(sizeof(int));
		if (pi != NULL)
		{
			//할당 성공
		}
		else 
			//할당 실패
- 캐스팅은 꼭 필요한가
	- void 포인터가 어느 타입의 포인터에도 할당이 가능해졌으므로, 명시적 호출은 더 이상 필요하지 않다.
	- 하지만 몇몇 개발자들은 다음과 같은 이유로 명시적 캐스팅이 좋은 습관이라 한다.
		- 명시적 캐스팅은 malloc함수의 사용 의도를 명확히 한다.
		- 명시적 캐스팅을 필요로 하는 C++ 또는 초기 C컴파일러와 호환 가능한 코드를 생성한다.

- malloc 함수에 적절하지 않은 크기 사용
	- 총 10개의 double 값을 위한 메모리 공간 할당(80바이트)
		- double * pd = (double *)malloc(NUMBER_OF_DOUBLES * sizeof(double));
		- 잘못된 예(단지 10바이트만 할당)
			const int NUMBER_OF_DOUBLES = 10;
			double *pd = (double *)malloc(NUMBER_OF_DOUBLES);
- 할당된 메모리 크기 알아내기
	- 힙에 의한 할당된 메모리의 전체 양을 알아내는 일반적인 방법은 존재하지 않는다. 또한 힙 관리자에 의해 할당된 메모리 블록의 크기를 알아내는 일반적인 방법도 존재하지 않는다.
	- 문자열 64바이트에 할당하면 힙 관리자는 이 블록을 관리하기 위해 추가로 메모리를 할당한다(64바이트 + 관리용 메모리 영역)

- 정적 포인터 및 전역 포인터에 malloc 사용하기
	- 정적 변수나 전역 변수는 선언 시 초기화를 위해 함수 호출을 사용할 수 없다.
	- static int * pi = malloc(sizeof(int)); // 컴파일 에러, 전역 변수도 마찬가지
	- 컴파일러 관점에서 초기화 연산자(=)의 사용과 할당 연산자(=)의 사용은 차이가 있다.
```c
static int * pi;
pi = malloc(sizeof(int));
// 정적 변수는 오류 피할 수 있다.
// 전역 변수는 함수 바깥에 선언되어야 하기 때문에 정적 변수와 달리 선언과 초기화를 분리할 수 없다.
```

- calloc 함수 사용하기
	- 메모리 할당과 동시에 초기화한다. 할당된 메모리의 첫 바이트를 가리키는 포인터를 반환한다.
	- 메모리를 할당할 수 없는 경우 NULL을 반환
	- 인자 중 하나라도 값이 0이면 NULL을 반환한다. 전역 변수 errno는 ENOMEM(out of memory)로 설정된다.
	- void * calloc(size_t numElements, size_t elementSize);
```c
int *pi = calloc(5, sizeof(int));
// malloc 함수와 memset 함수를 같이 사용하면 같은 결과를 얻는다.
int *pi = malloc(5 * sizeof(int));
memset(pi, 0, 5 * sizeof(int));
```
- memset 함수는 메모리 영역을 원하는 값으로 채운다. 첫 번째 인자는 메모리 영역에 대한 포인터다. 두 번째 인자는 메모리를 채우는 데 사용할 값이며, 마지막 인자는 채울 바이트 수를 나타낸다.
- 메모리 할당과 동시에 0으로 설정할 필요가 있을 때 calloc 함수를 사용하도록 하자. 그러나 calloc 함수의 실행이 malloc보다 더 길다

- realloc 함수 사용하기
	- void * realloc(void * ptr, size_t size);
	- 첫 번째 인자는 기존 할당된 메모리에 대한 포인터이며, 두 번째 인자는 요청할 메모리의 크기다.
	- 재할당된 메모리의 크기는 기존 메모리의 크기와 다르며, 반환 값은 재할당된 메모리의 포인터이다.
	- 새로 요청된 크기가 기존 크기보다 작으면 여분의 메모리는 힙으로 반환된다. 그리고 반환된 여분의 메모리의 초기화 여부는 보장되지 않는다.
	- 새로 요청된 크기가 기존 크기보다 크면 가능한 한 현재 메모리 영역의 바로 인접 영역에 이어서 메모리 할당한다.
	- 인접 영역에 메모리를 할당할 수 없는 경우, 힙의 다른 영역에 메모리를 할당하고 기존 메모리의 내용을 새로운 영역으로 복사한다.
	- 인자에 따른 realloc 함수 동작
		- (NULL), NA(바이트 수) : malloc 함수와 동일
		- (NULL아님), 0 : 기존 메모리 해제
		- (NULL아님), 기존 메모리 크기보다 작음 : 현재 메모리 영역 사용하여 작은 메모리 영역을 할당
		- (NULL아님), 기존 메모리 크기보다 큼 : 현재 메모리 영역이나 다른 메모리 영역을 사용하여 큰 메모리 영역 할당
```c
char *string1;
char *string2;
string1 = (char *)malloc(16);
strcpy = (string1, "0123456789AB");

string2 = realloc(string1, 8);
printf("%p %s\n", string1, string1); // 주소 500번지
printf("%p %s\n", string2, string2); // 주소 500번지 

// 추가적인 메모리 재할당
string1 = (char *)malloc(16);
strcpy(string1, "0123456789AB");
string2 = realloc(string1, 64);
printf("%p %s\n" stirng1, string1); // 주소 500번지
printf("%p %s\n" stirng2, string2); // 주소 600번지
```
- alloca 함수(=malloca)와 가변 길이 배열
	- 함수 내부에서 사용할 목적으로 스택 프레임 안의 메모리를 할당한다.
	- 함수(스택 프레임을 소유한)가 반환되면 alloca에 의해 할당된 메모리는 자동으로 해제된다.
	- 런타인 시스템이 스택 기반이 아니면 구현하거나 지원할 수 없다. (이식성 낮음)
	- 가변 길이 배열
	```c
	void compute(int size) {
		char buffer[size];
		...
	}
	```
	- 배열을 위한 메모리의 할당이 런타임에 결정되며, 스택 프레임 일부에 메모리가 할당된다. 또한, sizeof 연산자가 가변 길이 배열과 함께 사용되면 
	sizeof 연산자는 컴파일이 아닌 런타임에 실행된다.
	- 가변길이 배열은 함수 내에서 이미 크기가 결정된 다음에는 변경할 수 없다(메모리 해제시 free함수도 필요 없다);
	- 가변 길이 배열을 사용한 함수는 이 메모리에 대한 포인터를 반환해서는 안된다.

- free함수로 메모리 반환하기
	- void free(void * ptr);
	- free 함수의 인자는 malloc 타입 함수에 의해 할당된 메모리 주소를 전달받는다. 그리고 지정된 메모리는 힙 영역으로 반환된다.
	- 반환 후에도 여전히 포인터는 해당 메모리 영역을 가리킬 수 있으나 가비지 영역을 가리킨다고 가정한다. 힙으로 반환된 영역은 나중에 재할당될 수 있다.
```c
int *pi = (int *)malloc(sizeof(int));
...
free(pi);
```
- 주소 500의 점선으로 된 상자는 메모리가 해제 되었으나 여전히 그 값을 포함하고 있다. 포인터 변수 pi는 여전히 주소 500을 가리키고 있다. 이를 댕글링 포인터라 한다.
- 메모리 할당/ 해제를 같은 수준에서 관리하도록 하자. 특정 함수 안에서 할당되었다면 그 함수 내에서 해제하도록 하자. (저자의 권고사항)
- free 함수를 이용한 메모리 해제
	- free 함수 호출 시 인자로 널 포인터를 전달하면, 일반적으로 free 함수는 아무 일도 하지 않는다.
	- malloc 타입의 함수가 아닌 다른 함수에 의해 할당된 포인터를 인자로 전달했을 때 free 함수의 행동은 정의되어 있지 않다.
```c
int num;
int *pi = &num;
free(pi); // 정의되지 않은 행동
```
- 해제된 포인터에 NULL 할당하기
	- 포인터는 메모리가 해제된 이후에도 문제를 유발할 수 있다.
	- 메모리가 해제된 포인터를 역참조하면, 그 포인터의 행동은 정의되어 있지 않다.
	- 그 결과 몇몇 프로그래머들은 해제된 포인터가 더는 유효하지 않음을 표시하기 위해 명시적으로 NULL을 할당한다.
	- 이미 해제된 포인터의 사용은 런타임 예욍를 발생시킨다.
```c
int *pi = (int *)malloc(sizeof(int));
...
free(pi);
pi = NULL;
// 이 기법은 댕글링 포인터 같은 문제를 해결하기 위한 것이다. 하지만 단순히 널 포인터인지를 체크 하는 것보다는 문제를 발생시킨 상황을 해결하는 데 시간을 들이는 것이 낫다. 게다가, 초기화할 때를 제외하고는 상수에 NULL을 할당할 수 없다.
```
- 이중 해제(Double Free)란 메모리 해제를 두 번 시도하는 것을 말한다.
```c
// ex1
int *pi = (int *)malloc(sizeof(int));
*pi = 5;
free(pi);
...
free(pi);

// ex2
p1 = (int *)malloc(sizeof(int));
int *p2 = p1;
free(p1);
...
free(p2);

// 두 경우 모두다 런타임 에러 발생
```
- 힙 관리자는 메모리가 이미 해제되었는지 판단하지 못한다. 게다가 힙 관리자는 같은 메모리가 두 번 해제되려고 하는지도 발견하지 못한다. 메모리의 이중 해제 시도는 일반적으로 메모리를 손상시키거나 프로그램을 종료시킨다. 프로그램 종료와 같은 최악의 상황을 피하더라도 프로그램의 오작동을 유발한다. 일반적으로 해제된 메모리를 다시 해제하는 일은 발생하지 않는다. 
- free 함수가 메모리 해제 후 인자로 전달한 메모리의 포인터 반환 시, NULL 또는 약속된 특별한 값을 할당할 필요가 있다고 생각할지도 모른다. 그러나 포인터가 값으로(by value) 전달 되었기 때문에 free 함수는 명시적으로 인자로 전달된 포인터에 NULL을 할당할 수 없다.

- 힙 메모리와 시스템 메모리
	- free 함수가 호출되었다고 해서 힙 관리자가 반드시 해제된 메모리를 운영체제로 반환하는 것은 아니고, 애플리케이션에서 해당 메모리를 다시 사용할 수 있게 할 뿐이다. 그래서 프로그램이 메모리를 할당한 후 다시 해제한다고 해도, 일반적으로 운영체제 측면에서는 해제된 메모리가 애플리케이션의 메모리 사용량에 반영되지 않는다.

- 프로그램 종료시 메모리 해제
	- 운영체제는 메모리를 포함한 애플리케이션 리소스의 관리 책임이 있다. 운영체제는 애플리케이션 종료 시 사용된 메모리를 다른 애플리케이션이 재할당할 수 있도록 해야 하며, 종료된 애플리케이션의 메모리 상태가 손상되었는지는 중요하지 않다. ... 비정상 종료되는 프로그램이 메모리를 초기화하고 반환하는 일은 사실상 불가능하다. 그래서 사실, 애플리케이션의 종료 전에 메모리를 꼭 해제해야 할 필요는 없다.
	- 메모리가 해제 되어야 하는 다른 이유가 있을 수 있다. 양심적인 개발자들은 소프트웨어의 품질 문제로 메모리 해제를 원할 수도 있다. 비록 애플리케이션이 종료된다고 해도 더는 필요하지 않은 메모리를 해제하는 것은 좋은 습관이다.
	- 메모리 해제를 보장하는 일은 다음 사항을 고려해야 한다.
	1. 메모리 해제의 중요성에 비해 구현하기가 꽤 까다롭다.
	2. 구현에 따로 시간을 써야 하며, 복잡한 구초제의 경우 구현이 더 복잡하다.
	3. 애플리케이션의 크기가 늘어난다.
	4. 애플리케이션의 실행 시간이 길어진다.
	5. 메모리 해제 코드에서 새로운 오류가 발생하기 도한다.
	- 프로그램 종료 전에 메모리를 해제할 지 여부는 어디까지나 애플리케이션 구현에 달려있다.
- 댕글링 포인터(여전히 해제된 메모리 영역을 가리키는 포인터)
	- 댕글링 포인터가 가리키는 메모리는 더는 유효하지 않다(너무 빠른 해제, premature free 라고 불리기도 한다).
	- 아래 문제를 포함한 다양한 문제 발생
	1. 메모리 접근 시 예측 불가능한 동작
	2. 메모리 접근 불가 시 세그멘테이션 오류(Segmentation fault)
	3. 잠재적인 보안 위험
	- 다음과 같은 동작의 결과로 발생
	1. 메모리 해제 후, 해제된 메모리에 접근
	2. 함수 호출에서 자동 변수를 가리키는 포인터의 반환
```c
int *pi = (int *)malloc(sizeof(int));
*pi = 5;
printf("*pi: %d\n", *pi);
free(pi);
*pi = 10;
// 여전히 해당 메모리에 접근하여 쓰기를 시도할 수 있으며, 이러한 시도의 결과는 예측할 수 없다.

int *p1 = (int *)malloc(sizeof(int));
*p1 = 5;
...
int *p2;
p2 = p1;
...
free(p1);
...
*p2 = 10; // 포인터 에일리어싱에(Aliasing) 의한 댕글링 포인터
```
# Ch3. 포인터와 함수
# Ch4. 포인터와 배열
# Ch5. 포인터와 문자열
# Ch6. 포인터와 구조체
# Ch7. 보안 이슈와 포인터의 오남용
# Ch8. 기타
