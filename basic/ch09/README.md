### 9.1 클래스 템플릿
- 클래스를 찍어내는 모양자라고 생각하자.
- 템플릿에서 구조적으로 메모리를 자동 동적 할당 및 해제하며 복사 생성자와 이동 시맨틱을 지원하므로 성능도 좋다. 또한 개별 요소에 배열 연산자로 접근할 수 있으므로 배열과 동일한 사용자 경험을 제공한다.00
```c++
template <typename T>
class 이름 
{
}
```
#### 멤버 선언 및 정의
- 클래스 템플릿에서도 선언과 정의를 분리할 수 있으며 정적 멤버를 포함시키는 것도 가능하다. 다만, 정의가 분리되고 기술될 때마다 template<typename 형식>을 매번 선언해야 한다.
```c++
template<typename T>
클래스이름<T>::멤버함수이름()
{
}
```
#### 템플릿 매개변수
```c++
Template<typename T, typename T2> // 가능
Template<typename T, int i_size> // 가능
template<typename T = int, int i_size = 3> // 디폴트 값 지정 가능
```
### 9.2 템플릿 특수화
- 특별한 형식이 있을 경우 나머지 다른 형식들과 전혀 다른 코드를 적용해야 할 때가 있다. ex) 포인터는 일반적인 형식들과 달리 간접 지정 연산을 실행해야 하는 경우, 문자열에 덧셈을 적용할 경우...
```c++
template <typename T>
T add(T a, T b) { return a + b; }

template<>
char *add(char *p_size_left, char *p_size_right)
```
#### 클래스 템플릿 특수화
```c++
template<typename T>
class CMyData
{
};

template<>
class CMyData<char *> // T가 있었떤 모든 부분이 char *로 대체된다.
```
### 9.3 클래스 템플릿과 상속
```c++
template<typename T>
class CMyDataEx : public CMyData<T>
```
### 9.4 스마트 포인터
|            |                                                                                                                                                    |   |   |   |
|------------|----------------------------------------------------------------------------------------------------------------------------------------------------|---|---|---|
| auto_ptr   | 동적 할당한 인스턴스를 '자동'으로 삭제한다. 가장 오래 존재했던 스마트 포인터이다.                                                                 |   |   |   |
| shared_ptr | 포인팅 횟수를 계수해서 0이 되면 대상을 삭제한다.                                                                                                   |   |   |   |
| unique_ptr | shared_ptr과 달리 한 대상을 오로지 한 포인터로만 포인팅한다. 즉, 하나의 소유자만 허용한다.                                                        |   |   |   |
| weak_ptr   | 하나 이상의 shared_ptr 인스턴스가 소유하는 개체에 접근할 수 있게 하지만 참조 수로 계산하지 않는다. 특수한 경우에만 사용하고 거의 사용하지 않는다. |   |   |   |

#### auto_ptr
```c++
int main()
{
	{
		//속한 범위를 벗어나면 대상 객체는 자동으로 소멸한다.
		//배열로 동적할당하면 해제할 때 문제가 생긴다.
		//얕은 복사를 한 경우에도 문제가 생긴다. //단순 대입 연산이 일반적인 경우처럼 '복사'가 아니라 '이동'이 된다고 볼 수 있기 때문이다.
		auto_ptr<CMyData> ptr_test(new CMyData);
	}
}
```
#### shared_ptr
- shared_ptr은 auto_ptr과 달리 배열로 객체를 삭제할 수 있는 방법을 제공한다. 이 삭제함수는 개발자가 직접 작성하여 등록해주어야 한다.

#### unique_ptr
- shared_ptr과 유사하다, 하지만 한 대상을 오로지 한 포인터로만 포인팅할 수 있다.
#### weak_ptr
- 참조 형식으로 포인팅할 수 있다. 단순히 참조만 할 수 있을뿐, weak_ptr이 하나 늘거나 줄어든다고해서 참조 카운터에 영향을 주지는 않는다. 또한, weak_ptr이 소멸하더라도 대상 객체를 삭제하지도 않는다.
