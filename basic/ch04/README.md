## 4장.복사 생성자와 임시 객체
### 4.1 복사 생성자
- 객체의 복사본을 생성할 때 호출되는 생성자이다.
```c++
클래스이름(const 클래스이름 &rhs)
// 매개변수 이름을 rhs. right hand side의 약자. 즉 r-value라고 보기 대문이다. const예약어는 생략할 수 있지만 특별한 이유가 없다면 붙이는 것이 원칙이다.
```
- 매개변수가 참조자가 되었을 때 한가지 단점이 있다. 사용자의 코드만 보고서는 참조에 의한 호출(call by reference)인지 아닌지 알 수 가 없다.'
- 하지만 댕글링 포인터 문제나 의존 관계 분석 불가로 인한 코드 최적화 실패 등을 방지할 수 있다. 따라서 참조자로 대체할 수 있는 포인터는 무조건 대체하는 것이 좋다.
- 사용자 쪽에서 call by value인지 아닌지 알아야 하는 이유는 함수의 실인수로 기술한 변수가 함수 호출 때문에 값이 변경될 수 있기 때문이다.
- 그러므로 함수의 형식이 클래스 형식이라면 일단, 아니 무조건 상수형 참조로 선언해야 한다.
### 4.1 복사생성자
```c++
클래스이름(const 클래스이름 &rhs);
```
- 함수 호출과 복사 생성자
```c++
void test_func(CTest param) { }

void main()
{
	CTest a; // 객체의 복사본으로 생성
	test_func(a); // 함수 형태로 호출
}
```
- 반환 형식으로 사용되는 경우 '이름 없는 임시 객체'를 만들어 내는 문제가 발생할 수 있다.
- 복사 생성자를 삭제하는 방법이 아닌 매개변수를 참조자로 하였을 때 사본을 만들어내지 않고 호출하여 성능이 향상된다.
- 함수의 실인수로 기술한 변수가 함수 호출 때문에 값이 변경될 수 있기에 함수의 매개변수 형식이 클래스 형식이라면 무조건 상수형 참조로 선언해야 한다.
#### 깊은 복사와 얖은 복사
- 깊은 복사는 복사에 의해 실제로 두 개의 값이 생성되는 것이고 '얕은 복사'는 대상이 되는 값은 여전히 하나뿐인데 접근 포인터만 둘로 늘어나는 것을 말한다.
```c++
int *pa, *pb;
pa = new int;
*pa = 10;

pb = new int;
pb = pa; //얕은 복사. pb는 pa가 동적 생성한 int 인스턴스를 가리키게 된다. delete pa; delete pb; 를 할 경우 해제한 포인터를 다시 해제하려고 하는 오류가 발생함.

*pb = *pb; // 깊은 복사. 단순히 포인터 변수의 주소를 같은 값으로 만드는 게 아닌 pa포인터가 가리키는 대상 메모리에 저장된 값을 가져와 pb포인터가 가리키는 대상 메모리로 복사한 것이다.
```ㅜ
#### 대입연산자
