# 소켓 프로그래밍
- 온라인 게임에서 소켓은 파일 핸들과 약간 다르다
	- 게임 서버에서 다루어야 하는 소켓 개수가 많다. TCP를 이용해서 통신하는 경우 클라이언트 개수만큼 소켓이 있어야 한다.
	- 파일 핸들을 하는 동안 스레드가 대기하는 일이 없어야 한다. 소켓을 이용해 읽기/쓰기를 하는 함수를 호출했는데, 즉시 리턴하지 않는다면 이들을 호출한 메인스레드는 사용자 입장에서 일시 정지를 하는 것처럼 보인다.
- 이러한 이유들로 네트워크 프로그래밍에서 소켓은 보통 비동기 입출력(Asynchronous I/O)상태로 다룬다. 이러한 방식에는 논블로킹 소켓(non-blocking socket)방식과 overlapped I/O 방식이 있다. 그리고 이 방식들을 진보시킨 epoll과 I/O Completion Port(IOCP)방식이 많이 활용된다.

### 3.1 블로킹 소켓(blocking soket)
- 디바이스에 처리 요청을 걸어놓고 응답을 대기하는 함수를 호출할 때 스레드에서 발생하는 대기현상을 블로킹이라고 한다.
- 스레드에서 네트워크 수신을 하는 함수를 호출하면, 수신할 수 있는 데이터가 생길 때까지 스레드는 waitable 상태, 즉 블로킹이 발생한다.

### 3.2 네트워크 연결 및 송신
```c++
// 이 프로그램은 주소가 11.22.33.44인 기기에서 실행
main()
{
	s = socket(TCP); //1
	s.bind(any_port);//2
	s.connect("55.66.77.88:5959"); //3
	s.send("hello");//4
	s.close();//5
}
```
- 1은 소켓 핸들 s를 생성한다. 아직은 아무것도 할 수 없다.
- 2 s.bind(any_port)는 localhost 안에 있는 포트6만 5535개 중 사용 가능한 포트(빈 포트)를 차지한다. TCP 통신을 하려면 상대방 끝점 뿐만 아니라 자신의 끝점도 알아야 한다.
- 3 상대방 끝점을 향해 TCP연결을 시도한다.그리고 이 함수는 블록킹이 일어난다.
- 4 상대방 끝점을 향해 데이터를 전송한다. 단, 이 함수가 리턴했다고 해서 상대방이 데이터를 성공적으로 수신했다는 건 아니다
- 안타깝게도 이 코드는 우리 생각과 다르게 작동한다. 호출한 send()는 블로킹 없이 즉시 리턴한다. 

### 3.3 블로킹과 소켓 버퍼
- 소켓은 각각 송신 버퍼(send buffer)와 수신 버퍼(receive buffer)를 하나씩 가지고 있다. 먼저 송신 버퍼는 일련의 바이트 배열이라고 볼 수 있다. 크기는 고정되어 있으나 마음대로 크기를 변경할 수 있다. 큐와 마찬가지로 FIFO 형태로 작동한다.
- 앞에서 send()는 즉시 리턴한다. 송신 버퍼는 디폴트로 수천 바이트를 담을 수 있기 때문이다.

### 3.4 네트워크 연결받기 및 수신
```c++
// 이 프로그램은 주소가 55.66.77.88인 기기에서 실행
main()
{
	s = socket(TCP); // 1
	s.bind(5959); // 2
	s.listen(); // 3
	s2 = s.accept(); // 4
	print(getpeeraddr(s2)); // 5
	while (true) 
	{
		r = s2.recv(); // 6
		if (r.length <= 0) // 7
			break;
		print(r);
	}
	s2.close(); // 8
}
```
- 2 TCP 포트 5959를 점유한다. 이미 사용중인 경우 이 함수는 실패한다.
- 3 TCP 연결을 받는 역할을 시작하여 리스닝 소켓. 즉시 리턴
- 4 TCP 연결이 들어올 떄까지 기다린다. 리스닝 소켓은 연결을 수락하는 역할만 할 뿐 데이터를 주고받는데 사용되지 않는다
- 5 accept() 함수에서 새로운 소켓 핸들을 이용해 저쪽 끝점과 통신한다
- 6 새로운 소켓에서 데이터를 수신한다. recv()는 수신된 데이터를 리턴하지만, 수신할 수 있는 데이터가 없으면 블로킹이 일어난다.
- 7 TCP 소켓 수신 함수를 호출했을 때 받은 데이터 크기가 0바이트라면 tcp 연결을 끝냈음을 의미한다.
### 3.5 수신 버퍼가 가득차면 발생하는 현상
- 수신 함수가 수신 버퍼에서 데이터를 꺼내는 속도가 운영 체제가 수신 버퍼의 데이터를 채우는 속도보다 느리면 어떻게 될까?
- 수신 버퍼가 꽉차면, TCP로 데이터를 보내는 쪽에서 송신 함수인 send()가 블로킹 된다. TCP recv()를 전혀 하지 않으면 send()도 계속 블로킹 상태를 유지한다. 이 상태에서는 TCP 통신은 전혀 없고, TCP 연결만 살아 있는 것이다.
- UDP의 경우에는 수신 버퍼가 데이터그램 A를 담을 여유 공간이 없으면 데이터그램 A는 바로 버려진다. 즉, 송신 활동이 멈추지 않는다. 받는 쪽에서는 일부 데이터그램을 놓치게 된다.

### 3.6 논블록 소켓
- 소켓의 송신 버퍼에 빈 공간이 없으면 블로킹이 발생하며, 조금이라도 빈 공간이 생기면 블로킹이 끝나고 소켓함수는 리턴된다. 대부분 운영체제에서 소켓 함수가 블로킹 되지 않게 API를 추가로 제공하는데, 이를 논블록 소켓이라고 한다.
	- 소켓을 논블록 소켓으로 모드 전환한다.
	- 논블록 소켓에 대해 평소처럼 송신, 수신, 연결과 관련된 함수를 호출한다.
	- 논블록 소켓은 무족건 이 함수 호출에 대해 즉시 리턴한다. 리턴 값은 '성공' 혹은 'would block' 오류 둘 중에 하나이다.
	- would block은 '블로킹 걸려야 할 상황인데, 자네는 참 운이좋아. 블로킹 안걸렸잖아?'라는 의미이다.

### 3.7 Overlapped I/O 혹은 비동기 I/O
- 논블록 소켓
	- 장점
		1. 스레드 블로키잉 없으므로 중도 취소 같은 통제 가능
		2. 스레드 개수가 1개이거나 적어도 소켓 여러개 다룰 수 있음
		3. 스레드 개수가 적거나 1개이므로 연산량이 낭비되지 않음. 호출스텍 메모리도 마찬가지.
	- 단점
		1. 소켓 I/O 함수가 리턴한 코드가 would block인 경우 재시도 호출 낭비 발생
		2. 소켓 I/O 함수 호출할 때 입력하는 데이터 블록에 대한 복사 연산 발생
		3. connet() 함수는 재시도 호출을 하지 않지만, send()나 receive()함수는 재시도 호출해야 하는 API가 일관되지 않는 문제
- CPU 안에 있는 캐시 메모리에 메모리 내용이 복사되어 있으면 데이터 엑세스는 매우 빠르다. 하지만 캐시에 없는 데이터를 액세스 할 때 메인 메모리는 RAM을 액세스 하는데 이속도는 매우 느리다. 따라서 고성능 서버를 개발할 때는 이 복사 연산도 무시할 수 없는 변수가 된다.
- Overlapped 또는 Asynchronous(비동기) I/O는 재시도용 호출 낭비 문제와 소켓 함수에 대한 데이터 블록 복사 부하 문제를 모두 해결해준다.
- 논블록 소켓은 데이터를 이렇게 다룬다
	- 소켓 I/O 가능인 것이 있을 때까지 기다린다
	- 소켓에 대해 논블록 액세스를 한다
	- would block이 발생하면 그대로 두고, 그렇지 않으면 실행 결과 리턴 값을 처리한다.
- Overlapped I/O에서는 다르게 한다.
	- 소켓에 대해 Overlapped 액세스를 건다.
	- 액세스가 성공했는지 확인 후 성공했으면 결과값을 얻어 나머지 처리.
- 완료 되기 전까지 Overlapped status 객체가 데이터 블록을 중간에 훼손하지 말아야 한다.
- 소켓 갯수가 많을 때 루프를 돌며 진행하는 방식이 결국 성능문제를 일으킨다. 그래서 등장한 것이 IOCP(Input/Output Completion Port)와 epoll이다.
### 3.8 epoll
- epoll 소켓이 I/O 가능 상태가 되면 이를 감지해서 사용자에게 알림을 해주는 역할을 한다.
```c++
epoll = new epoll(); // 1
foreach(s in sockets)
{
	epoll.add(s, GetUserPtr(s)); // 2
}
events = epoll.wait(100ms); // 3
foreach(event in events) // 4 
{
	s = event.socket; //5 
	UserPtr = event.userPtr;
	type = event.type;
	if (type == ReceiveEvent)
	{
		(result, data) = s.recv();
		if (data.length > 0)
		{
			Process(userPtr, s, data);
		}
	}
}
```
- 1 epoll 객체를 만든다
- 2 여러 소켓을 epoll에 추가한다.
- 3 모든 소켓에 대한 select() 대신 epoll에서 이벤트를 꺼내오는 함수를 호출한다. 이 함수는 사용자가 원하는 시간까지만 블로킹되며, 그 전에 이벤트가 생기는 순간 즉시 리턴한다.
- 4 각 이베트에 대해 루프를 돌며 이벤트가 가리키는 소켓 객체와 사용자 정의 값을 꺼내온다
- 5 원하는 처리를 한다.
### 3.9 IOCP
- epoll은 논블록 소켓을 대량으로 갖고 있을 때 효율적으로 처리해주는 API이다. Overlapped I/O는 이에 대응한 것이다.
```c++
iocp = new iocp(); //1
foreach(s in pockets)
{
	iocp.add(s, GetUserPtr(s));//2
	s.OverlappedReceive(data[s],
		receiveOverlapped(data[s]); //6 
}
events = iocp.wait(100ms); // 3
foreach(event in events) // 4
{
	//5
	// 위 iocp.add에 들어갔던 값을 얻는다.
	userPtr = event.userPtr;
	ov = event.overlappedPtr;
	s = GetSocketFromUserPtr(userPtr);
	if (ov == receiveOverlapped[s])
	{
		// overlapped receive가 성공했으니 받은 데이터를 처리
		Process(s, userPtr, data[s]);
		s.overlappedReceive(data[s],
			receiveOverlapped[s]); // 6
	}
}
```
- 1 IOCP 객체를 만든다.
- 2 여러 소켓과 소케에 대응하는 여러분이 원하는 정수 값(epoll의 userptr과 동일)을 IOCP에 추가한다. 6 추가된 소켓의 I/O 이벤트는 IOCP를 이용하여 감지할 수 있다. I/O를 하고 싶으면 overlapped I/O를 건다
- 3 모든 overlapped status 객체에 대한 GetOverlappedResult 대신 IOCP에서 완료 신호를 꺼내 오는 함수를 호출합니다. 이 함수는 사용자가 원하는 시간까지만 블로킹되며, 그 전에 이벤트가 생기면 즉시 리턴합니다.- 4 각 이벤트에 대한 루프를 돌면서 5 이벤트가 가리키는 overlapped cstatus 객체와 대응하는 userptr값을 꺼내온 후 원하는 처리를 하면 된다.
- epoll은 I/O 가능인것을 알려주지만, IOCP는 I/O완료인 것을 알려준다.
