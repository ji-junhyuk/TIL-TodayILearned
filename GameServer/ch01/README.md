## ch01. 멀티스레딩
### 1-1 프로그램과 프로세스
- 프로그램이란 컴퓨터에서 실행되는 명령어 모음이 들어 있는 데이터 덩어리를 의미한다. 크게 코드(code)와 데이터(data)로 구성되어 있다.
- 프로세스(process)란 프로그램을 실행하면 프로그램 안에 들어 있는 명령어가 한 줄씩 실행되면서 프로그램은 뭔가 활동을 하는 상태가 되는 것을 말한다.
- 프로그램에 있는 코드와 데이터는 이 프로세스 메모리로 불러들인다. 프로세스 메모리에는 프로그램 코드와 데이터는 물론, 힙(heap)과 스택(stack)도 공존한다.
- 프로그램은 디스크 같은 저장소에 있고, 프로세스는 RAM 메모리에 있다.
- 프로세스가 여러 개 실행되고 있는 것을 멀티프로세싱(multi-processing)이라고 한다.
### 1-2 스레드
- 각 프로세스는 독립된 메모리 공간이 있다. 기본적으로 서로 다른 프로세스는 상대방의 메모리 공간을 읽고 쓸 수 없다.
- 대부분의 운영체제는 스레드(thread)라는 기능을 제공한다. 스레드 역시 프로세스처럼 명령어를 한 줄씩 실행하는 기본 단위이다.
- 즉, 프로그램이 실행되는 기본 단위는 스레드이다.
```c++
프로그램을 실행하면 프로세스가 생성된다. 프로세스 안에는 유일한 스레드가 있고 그 안에서 프로그램이 실행된다.
```
- 동시에 하나만 실행되는 프로그램을 싱글스레드 프로그램이라고 한다. 이렇게 설계하고 구현한 것을 싱글스레드 모델(single threaded model)이라고 한다.
- 프로그램이 싱글 스레드로 작동하는 동안, 프로세스 안에서 여러 스레드를 생성시킬 수 있다. 그리고 이런 여러 스레드는 동시에 실행된다. 여러 스레드가 동시에 여러 가지 일을 처리하게 하는 것을 멀티스레드 모델 혹은 멀티스레딩이라고 한다.
#### 스레드와 프로세스의 차이점
1. 스레드는 한 프로세스 안에 여러개가 있다.
2. 한 프로세스 안에 있는 스레드는 프로세스 안에 있는 메모리 공간을 같이 사용할 수 있다.
3. 스레드마다 스택을 가진다. 각 스레드에서 실행되는 함수의 로컬 변수들이 스레드마다 있다는 것을 의미한다.
- C언어에서는 운영체제마다 스레드 생성하는 함수가 다르다. 하지만, C++에서는 통일되었다.
```c++
std::thread t1(ThreadProc, 123);
```
### 1.3 멀티스레드 프로그래밍은 언제 해야 할까?
- 멀티스레드 프로그래밍은 똑같은 연산을 하더라도 연산 속도고 훨씬 더 느려지기도 하고, 조금만 실수해도 심각한 오류가능성이 있다.
- 멀티스레드 프로그래밍을 해야하는 대표적인 상황
1. 오래 걸리는 일 하나와 빨리 끝나는 일 여럿을 같이 해야 할 때
2. 어떤 긴 처리를 진행하는 동안 다른 짧은 일을 처리해야 할 때
3. 기기에 있는 CPU를 모두 활용해야 할 때

#### 첫번째 상황
- (게임을 켜고 게임 스테이지 안에 들어가기 전에, 게임 프로그램은 케릭터와 배경을 구성하는 그래픽 리소스를 로딩하기 위해 많은 양의 데이터를 디스크에서 읽어와야 한다.)
- 멀티스레딩을 하지 않는다면 로딩하는 동안 다른 뭔가를 하도록 구현해준다. (코드가 지저분해지고, 로딩하는 파일이 크다면 일시적으로 프레임률이 뚝뚝 끊길 것이다)
```c++
bool isStillLoading;

Thread1
{
	isStillLoading = true;
	while (isStillLoading)
	{
		// 게임 루프를 돌면서 지속적으로 렌더링을 수행한다.
		FrameMove();
		Render();
	}
}
Thread2
{
	LoadScene();
	LoadModel();
	...
}
```

#### 두번째 상황
- 플레이어 정보를 읽거나 쓰려고 디스크를 엑세스하는 경우이다. 디스크를 엑세스하는 스레드는 디스크의 처리 결과가 끝날 때까지 기다려야 하는데, 이 시간동안 CPU는 놀게 된다. 
- 플레이어 정보를 디스크에 기록하는 시간은 1만분의 1초 정도이지만, 상용 게임 서버입장에서는 엄청난 시간 낭비가 될 수 있다.
- CPU 속도는 크게 증가하지 않았다. 서버가 8코어 CPU를 장착했는데, 싱글스레드로 게임 서버를 만든다면 서버는 전체 연산 성능의 1/8만 사용하는 꼴이다.

### 1.4 스레드 정체
- CPU는 하나인데 어떻게 여러 프로그램이 동시에 실행될 수 있을까요? 여러 프로세스나 여러 스레드가 동시에 실행될 수 있을까요?
- 여러 프로세스와 여러 스레드를 동시에 실행해야 하는 운영체제는 이렇게 여러 프로세스와 각 프로세스 안에 스레드들을 일정 시간마다 번갈아 가면서 실행한다. 각 스레드를 실행하다 말고 다른 스레드를 마저 실행하는 과정을 컨텍스트 스위치(context switch)라고 한다.
```c++
컨텍스트 스위치를 하는 과정에서 적지 않은 양의 연산이 발생한다. 우선 실행 중이던 스레드의 상태(호출 스택)를 어딘가에 저장하고, 과거에 실행하다가 만 다른 스레드 중에서 하나를 고른다. 고른 스레드의 상태(호출 스택 등)을 복원하고, 그런 다음 실행지점으로 강제 이동한다.
============================================================
컨텍스트 스위치를 자주 할수록 성능이 안좋아진다고 하니, 최대한 덜하는 방향을 생각해보자.
ex) 로딩 중에 애니메이션을 뿌리는 경우를 생각.
컨텍스트 스위치가 어떤 스레드를 일시 정지하고 다시 컨텍스트 스위치로 실행을 마저하는데 1초라면, 로딩 중에 애니메이션은 1초에 한번 밖에 실행되지 못한다. 사람이 보는 입장에선 답답하게 보일 것이다.
사람 입장에서 쾌적할 수 있는 시간 단위를 타임 슬라이스(time slice)라고 한다. 보통 스레드 하나가 일시 정지했다 다시 시작하는데까지 걸리는 시간은 약 5밀리초이다. 컴퓨터 입장에서 초당 5억개를 처리할 수 있는 CPU라면 5억 * 5밀리초 = 250만개의 명령어를 처리할 수 있는 시간이다.
=============================================================
CPU 개수와 스레드 개수가 같거나 스레드 개수가 더 적으면 컨텍스트 스위치가 발생할 이유가 없다. 하지만 스레드 개수가 더 많으면 이는 발생한다. 단, Runnable 상태의 스레드가 CPU개수보다 많을 경우 성능문제가 될 뿐이다. waitable 상태의 스레드는 이러한 성능문제가 없다.
=============================================================
c나 c++로 프로그래밍을 하는 경우, 한 구문은 실제로 기계어 명령 여러개로 컴파일 된다. <컨텍스트 스위치>는 기계어 명령어 단위로 일어난다. 따라서 소스의 한 줄 구문 안에 있는 것을 실행하다 말고 컨텍스트 스위치를 할 가능성이 있는 것이다.
```
```c++
b = a * 2;
이를 기계어로 실행한다면,
1. ...
2. r1 = a //r은 레지스터, a는 메모리공간
3. r2 = r1 * 2
4. b = r2
5. ...
4번을 실행한 후 5를 실행하기 전에 무족건 컨텍스트 스위치가 실행된다면, 이 C언어 구문은 항상 정확한 결과가 나온다. 그러나 불행히도 우리는 컴퓨터가 1~5 중 어디까지 실행한 후 컨텍스트를 스위치를 일으킬지 예상할 수가 없다.
```
### 1.5 스레드를 다룰 때 주의사항
- 이전 소수구하기 프로그램에서 어느 부분이 잘못되었을까?
```c++
Array<int> primes;
...
while (num <= 100000)
{
	if (IsPrime(num))
		primes.Add(num);
	num++
}
...
================= 기게어 부분.
r1 = num
r1 = r1 + 1
num = r1
...
```
- 여러 줄이기에 컨텍스트 스위치를 할 때 어디서 실행하다 멈추어야 할지 모른다.
- 각 스레드는 소수를 찾아내면 Array<int> 객체에 Add()함수를 사용하여 배열 맨 뒤를 채운다. 기존에 가진 배열 객체에 더 이상 넣을 공간이 없으면, 메모리를 재할당한다. 두 스레드가 동시에 Array<int> Add()함수를 호출하면 여러 스레드가 Array<int> 변수들을 변경한다. 그러면 두 변수 중 하나만 변경된 상태에서 다른 스레드가 그대로 배열에 접근한다. (해제된 메모리에 접근할 수도 있기 때문에 충돌이 발생하는 것이다)
- 따라서, Array<int>스레드가 엑세스할 때는 Array<int> 안의 두 멤버 변수를 모두 바꾸든지, 아니면 하나도 바꾸지 않든지 해야 한다. 즉, 두 멤버 변수를 건드리는 동안에는 다른 스레드가 절대 건드리지 못하게 해야 한다. 이를 원자성(atomicity)라고 한다. 그래야 Array<int>의 두 변수는 항상 일관성(consistency)를 유지할 수 있다.
- 멀티스레드 프로그래밍을 할 때 이렇게 원자성과 일관성을 유지하는 특수한 조치를 해야할 때가 있다. 이러한 조치들을 통칭하여 동기화(syncronize)라고 하며, 대표적인 것이 임계영역과 뮤텍스, 잠금 기법이다.

### 1.6 임계 영역과 뮤텍스
- 경쟁 상태를 해결 하는 여러방법 중 하나
	- "스레드에서 어떤 정보 X를 사용하고 있는 동안 다른 스레드는 X를 건드리지 못하게 한다!"
	- "다른 스레드는 X를 건드리려고 하면 기다린다. 현재 스레드가 X를 다 사용할 때까지!". 이때 사용하는 것이 뮤텍스(mutex)이다. 뮤텍스는 상호 배제(mutual exclusion)의 줄임말이다.
- 뮤텍스를 사용하는 방법
	1. X, Y를 보호하는 뮤텍스 MX를 만듭니다.
	2. 스레드는 X, Y를 건드리기 전에 MX에 "사용권을 얻겠다."라고 요청합니다.
	3. 스레드 X, Y를 액세스합니다.
	4. 액세스가 끝나면 MX에 "사용권을 놓겠다."라고 요청합니다.
```c++
	std::mutex mx; // 1
	lock(); // 2
	read(x); // 3
	write(y); // 3
	sum(x); // 3
	mx.unlock(); // 4
```
- 스레드 1이 <2>에서 뮤텍스 사용권을 얻는 데 성공하면 <3>으로 넘어간다. 그러나 <2>를 하려고 했더니 이미 다른 스레드 2가 <2>의 사용권을 얻은 상태라, 스레드 1은 더 이상 진행하지 못하고 그 자리에서 진행합니다. 한편 스레드 2에서 실행은 <3>을 넘어 <4>로 넘어갑니다. 스레드 2에서 실행지점이 <4>를 통과하면 그제서야 스레드 1은 뮤텍스 사용권을 얻어 실행 지점이 <3>으로 넘어간다.
- 뮤텍스는 다른 말로 임계 영역(critical section)이라고도 한다. 멀티스레드 프로그래밍에서 뮤텍스에 대한 사용권을 얻는 과정을 '잠근다(lock)'고도 표현한다. (매번 lock()과 unlock()을 호출하는 것은 번거로울 뿐 아니라 예외 처리 코드 작성도 어렵다)
```c++
std::mutex mx; // 1
mx.lock() // 2
read(x) // 3
write(y); // 4
sum(x); // 5
mx.unlock(); // 6
```
- 3을 실행하다가 c++ 예외를 던지면 4~6은 실행되지 못한다. 이를 해결하려면 try-catch 구문으로 감싸 예외가 발생하더라도 unlock을 실행할 수 있게 해야 한다. 벌써부터 귀찮지 않나요?
- C++에서 로컬 변수가 파괴될 때, 파괴자 함수에서 여러분이 원하는 코드가 실행되게 할 수 있다. 뮤텍스 잠금 상태를 로컬 변수로 저장하고, 그 변수가 사라질 때 자동으로 잠금 해제가 되게 하는 클래스를 제공한다. 바로 lock_guard이다.
```c++
std::recursive_mutex mx;
lock_guard<recursive_mutex> lock(mx);
read(x);
write(x);
sum(x);
```
- prime_number_multithreaded.cpp
	- 스레드가 하나일 경우 실행시간이 3900밀리초인데, 왜 4일 때는 1300밀리초가 나왔을까?
	- 스레드의 메인 루프를 보자.
```c++
int n;
{ // 1
	lock_guard<recursive_mutex> num_lock(num_mutex);
	n = num;
	num++;
}
if (n >= MaxCount)
	break;

if (IsPrimeNumber(n))
{ // 2
	lock_guard<recursive_mutex> primes_lock(primes_mutex);
	primes.push_back(n);
}
```
- 1,2 구간에서 락(lock)을 하고 있어 다른 스레드가 대기 상태로 전환하는 상황이 발생한다. 이는 100% 완전히 모든 스레드가 runnable상태가 아닐수도 있다는 의미이기도 한다. 그런데 소수를 계산하는 연산은 1, 2구간보다 훨씬 많은 양을 연산한다. 1, 2도 성능부 불만족의 이유(lock)될 수 있지만, 그 비중이 크지 않다.
- CPU가 여러개지만, 결국 CPU는 메모리에 접근한다. CPU가 다루는 메모리는 기판에 연결되어 있는 다른 부품에 있다. 기판 회로를 통해 데이터를 주고받는 과정은 CPU입장에서는 매우 긴 시간이다. CPU 안에 캐시 메모리(cathe memory)가 있는 이유도 이 시간을 대폭 줄이기 위해서다. 하지만 CPU 안에 캐시된 메모리 또한 여러 CPU가 접근할 때는 CPU 안에서 블로킹이 약간 발생한다. 즉, 멀티스레드로 작동한다 하더라도 메모리에 접근하는 시간 동안에는 CPU 개수보다 더 적은 수의 CPU를 처리하게 된다는 의미이다. 이렇게 메모리에 접근하는 시간을 메모리 바운드 시간(memory bound time)이라고 한다.
- 일반적으로 서버는 4코어가 기본이고, 보통 8코어 이상도 장착하다. 그러다 보니 메모리 액세스의 양을 최대한 줄이는 것이 곧 서버 성능을 잘 사용하는 길이기도 하다. 아무튼 CPU 갯수가 많더라도 100% 성능을 다 사용하지 못한다.
- "뮤텍스를 최대한 잘게 나누는 것이 이상적이지 않을 까?"
	- 오히려 프로그램 성능이 떨어진다. 뮤택스를 액세스하는 과정 자체가 무겁기 때문이다.
	- 프로그램이 매우 복잡해진다. 교착 상태(dead lock)문제가 쉽게 발생한다.
- 지나치게 자잘한 임계 영역
```c++
class Player
{
	CriticalSection m_positionCritSec;
	Vector3 m_position; // 1
	CriticalSection m_nameCritSec;
	string m_name; // 2
	CriticalSection m_hpCritSec;
	int m_hp; // 3
}
```
- 각 클래스 멤버 변수마다 뮤텍스를 둔다. 이 변수들을 무조건 1~3순서로 액세스한다는 규칙을 지키면서 코딩해야만 교착 상태를 피할 수 있다. 프로그램이 구구단 수준으로 단순하다면 몰라도 크기가 커진다면 자꾸만 증가하는 규칙을 감당하기가 어렵다.
- 뮤텍스는 어느 정도 굵직하게 잠금 범위를 잡아야 한다. 그렇다고 범위를 너무 넓게 잡으면(극단적으로 프로그램 내부 전체 데이터를 한꺼번에 보호하는 단 하나의 뮤텍스) 싱글스레드로 작동하는 프로그램과 다를 바가 없다.
- 동시에 (여러 CPU가 병렬로) 연산하면 유리한 부분은 잠금 단위로 나누고, 병렬로 하지 않아도 별로 성능에 영향을 주지 않는 부분들은 잠금 단위를 나누지 않는 것이 좋다.
- 컨텐션(contention)이란 두 스레드가 동시에 한 데이터를 액세스하려는 상황을 의미한다. 두 스레드 중 하나 이상이 읽기 또는 쓰기를 할 때 뮤텍스로 잠금을 해서 보호하지 않으면 경쟁상태가 발생하는 문제가 생긴다. 또 뮤텍스로 잠금을 할 때는 한 스레드가 일을 하는 동안 다른 스레드가 모두 대기를 함으로써 병렬성이 사라지는 문제가 생긴다. 컨텐션은 멀티스레드 프로그래밍에서 불가피하다.
### 교착 상태
- 멀티스레드 프로그래밍에서 교착 상태란 두 스레드가 서로를 기다리는 상황을 의미한다. 스레드 1은 스레드 2가 하던 일이 끝날 때까지 기다리는데, 정작 스레드 2는 스레드 1이 하던 일이 끝날 때까지 기다리는 상황이다. 이러한 경우 두 스레드는 영원히 멈추어 있다.
- 게임 서버에서 교착 상태가 되면 발생하는 현상
	1. CPU 사용량이 현저히 낮거나 0%이다. 동시접속자 수와 상관없다.
	2. 클라이언트가 서버를 이용할 수 없다. 예를 들어 로그인을 못하거나 뭔가 요청을 했는데 응답이 오지 않는다.
- 교착 상태를 일으켰을 때 디버거로 원인을 찾는 방법(CRITICAL_SECTION)
	- 임계 영역 생성은 InitializeCriticalSectionEx로 한다. 이때 CRITICAL_SECTION 객체가 생성된다.
	- 임계 영역 제거는 DeleteCriticalSection으로 한다.
	- 임계 영역 잠금은 EnterCriticalSection으로 한다.
	- 임계 영역 잠금 해제는 LeaveCriticalSection으로 한다.
### 잠금 순서의 규칙
- 여러 뮤텍스를 사용할 때 교착 상태를 예방하려면 각 뮤텍스의 잠금 순서를 먼저 그래프로 그려두어야 한다. 그리고 잠금을 할 때는 잠금 순서 그래프를 보면서 거꾸로 잠근 것이 없는지 체크해야한다.
- A -> B -> C(잠금)
```c++
lock(A)
lock(B)
lock(C)
unlock(C)
unlock(B)
unlock(A)
```
- A -> B 잠금 안전하다
- B -> C 잠금 안전하다
- A -> C 잠금 안전하다.
- B -> A || C -> A 교착 상태를 일으킨다.
- 뮤텍스는 재귀성을 가지는 것과 가지지 않는 것이 있다.
	- 재귀 뮤텍스(recursive mutex)는 한 스레드가 뮤텍스를 여러 번 반복해서 잠그는 것을 원활하게 처리해준다.
```c++
// 재귀 뮤텍스
lock(M) // 잠금을 획득했다
lock(M) // 잠근 것을 또 잠궜다
unlock(M) // 잠금이 해제 되었다. 그러나 아직 한번 더 남았다.
unlock(M) // 잠금이 실질적으로 해제되었다.
```
- A -> B -> C -> B -> A
```c++
lock(A)
lock(B)
lock(C)
lock(B)
lcok(A)
unlock(C)
unlock(B)
unlock(A)
```
- C -> B -> A 는 잠금 순서 그래프와 거꾸로 가고 있다. 교착상태일까?
- 아니다. 이미 잠근 것에 대한 재귀 잠금은 그래프와 상관이 없다. (A -> B -> C를 통해 첫 잠금을 순서대로 완료했기에 이미 잠근 것을 또 잠구는 것은 순서 그래프를 무시해도 된다.)
- 잠금을 해제하는 순서는 마음대로 해도 교착 상태를 일으키지 않는다.
- "교착 상태를 예방하려면 첫 번째 잠금 순서를 지켜야 한다."
### 1.9 병렬성과 시리얼 병목
- 여러 CPU가 각 스레드의 연산을 실행하여 동시 처리량을 올리는 것을 병렬성(parallelism)이라고 한다. 그런데 어떤 이유로 병렬성이 제대로 나오지 않는 것, 즉 병렬로 실행되게 프로그램을 만들었는데 정작 한 CPU만 연산을 수행하는 현상을 시리얼 병목(serial bottleneck)이라고 한다.
- 소수 구하는 프로그램의 각 스레드가 하는 일을 의사코드로 살펴보기
	1. num을 잠근다
	2. num에서 값을 하나 가져온다
	3. num을 잠금 해제 한다
	4. num이 소수인지 판별한다
	5. 소수면 primes를 잠근다
	6. primes에 소수를 넣는다
	7. primes를 잠금 해제한다
- 1~3에서는 잠금이 발생한다. 다른 스레드가 1~3을 실행하려고 하면 그 스레드는 일지 정지된다. 마찬가지로 5~7에서도 같은 일이 발생한다.
- 즉 잠구는 구간이 있기에 동시에 실행될 수 없다. CPU가 많아질수록 시리얼 병목이 존재하는 시간이 길어진다. CPU개수가 많을수록 총 처리 효율성이 떨어지는 현상을 가리켜 암달의 법칙(Amdahl's Law)라고 한다.

### 1.10 싱글 스레드 게임서버
- 싱글 스레드 서버를 구동하는 경우 CPU 개수 만큼 프로세스를 띄우는 것이 일반적이다.
- 싱글 스레드로 게임 서버를 만드는 경우, 디스크에서 플레이어 정보를 로딩할 때 발생하는 디바이스 타임을 처리하는 과정에서 큰 시리얼 병목이 일어난다. 이를 해결하고자 비동기 함수나 코루틴 같은 것을 사용하기도 한다. 부득이한 경우가 아니면 방 개수나 플레이어 개수만큼 스레드 혹은 프로세스를 띄우는 것은 피해야 한다.
	1. 방 개수만큼 스레드나 프로세스가 있으면 스레드나 프로세스 간 컨텍스트 스위치의 횟수가 증가한다
	2. 따라서 같은 동시접속자를 처리하는 서버라고 하더라도 실제로 처리할 수 있는 동시접속자 수를 크게 떨어뜨린다.

### 1.11 멀티스레드 게임 서버
- 다음과 같은 경우에 멀티스레드로 서버를 개발한다
	1. 서버 프로세스를 많이 띄우기 곤란할 때, 예를 들어 프로세스당 로딩해야 하는 게임 저보(맵 데이터)의 용량이 매우 클 때(특히 MMO 게임 서버)
	2. 서버 한 대의 프로세스가 여러 CPU 연산량을 동원해야 할 만큼 많은 연산을 할 때
	3. 코루틴이나 비동기 함수를 쓸 수 없고 디바이스 타임이 발생할 때
	4. 서버 인스턴스를 서버 기기당 하나만 두어야 할 때
	5. 서로 다른 방이 같은 메모리 공간을 액세스 할 때
- 멀티스레드 게임 서버는 잠금 범위를 설정해주어야 하는데, 보통은 방 단위로 잠금 범위를 설정하는 것이 적정하다.
```c++
// 싱글 스레드 서버
class MyGameServer
{
	class Room
	{
		string m_roodName;
		List<Player> m_players;
		List<Character> m_characters;
	}
	map<PlayerID, shared_ptr<Room>> m_roomList;
	String m_serverName;
}

// 멀티 스레드 서버
class MyGameServer
{
	class Room
	{
		Critical Section m_critSec; // 각 게임방 안의 데이터들을 보호한다.
		...
	}
	string m_serverName;
	CriticalSection m_critSec; // 서버 메인과 방 목록을 보호한다. 단, 방안의 데이터는 보호하지 않는다.
}
```
- 플레이어 행동에 대한 처리는 각 방을 잠근 후에 한다.
	1. 공통 데이터(빵 목록)를 잠급니다.
	2. 플레이어 A가 들어 있는 방을 방 목록에서 찾습니다.
	3. 공통 데이터를 잠금 해제합니다.
	4. 찾은 방을 잠급니다.
	5. 플레이어 A의 방 안에서 처리를 합니다.
	6. 방을 잠금 해제합니다.
```c++
MyGameServer.DoSomething(player ID)
{
	lock(m_critSec);
	room = m_roomList.find(player);
	Unlock(m_critSec);
	lock(room.m_critSec);
	room.DoSomething(playerID);
	Unlock(room.m_critSec);
}
```
- 멀티스레드 게임 서버를 만들 때 크게 주의할 점은 시리얼 병목과 교착 상태이다. 특히 파일을 액세스 할 때 자주 잠그는 뮤텍스를 잠근 채로 액세스 하는 경우 성능 저하가 자주 발생한다.

### 1.12 스레드 풀링
- 멀티스레드 모델의 게임 서버를 개발할 때 스레드는 몇 개 만들고, 각 스레드는 무엇을 위해 일을 하게 만들면 좋을까?
- 클라이언트마다 스레드를 배정해주는 것 (개발 방식은 쉽지만 스레드 개수가 많을수록 여러 문제가 발생한다는 단점이 있다)
	- 각 스레드는 호출 스택을 가지는데, 이것의 크기가 작게는 수십 킬로바이트에서 수 메가바이트에 이른다. 또 다른 문제는 컨텍스트 스위치 현상이다. 게임 서비스 특성상 클라이언트는 서버와 통신하는 횟수가 잣다. 클라이언트 5000개가 초당 100회를 처리해야 하는 이벤트가 발생한다면 컨텍스트 스위치를 하는 횟수는 최대50만번에 이른다.
- 스레드 풀링은 공중화장실에 비유할 수 있다
	- 여러 문 앞에서 일렬로 줄을 서서 기다린다.
	- 각 문은 스레드이다. 줄 서 있는 사람들은 처리할 이벤트이다.
	- 스레드 갯수가 CPU 갯수보다 적다면?
		- 8코어인데 6스레드라면 최대 6개 병렬로 실행하고, 2개는 배정받지 못한다.
	- 스레드 갯수가 CPU 갯수보다 많다면?
		- 10코어라면 최대 10개로 병렬로 실행한다. 10개 중 8개는 각각의 CPU에 배정되고, 배정받지 않은 스레드 2개는 이미 일을 배정받은 CPU가 중복해서 배정받는다. 중복해서 일을 배정받는 스레드는 컨텍스트 스위치를 하면서 두 스레드를 실행한다. (컨텍스트 스위치는 운영체제 안에서 많은 연산이 필요하므로 결과적으로 매우 나쁜 속도)
```c++
// 서버에서 사용자 인증 요청을 처리하는 함수
void RequestLogin(userName, password)
{
	// 사용자 정보를 파일에서 불러온다
	// 파일 액세스가 끝날 때까지는 하드디스크가 바쁘고, CPU는 논다
	string prof = File.GetUserProfile(userName);
	if (password == prof.password)
	{
		// 사용자 인증 처리;
	}
}
```
- 예를 들어 CPU가 8개 있고, 스레드를 8개 갖고 있다고 생각해보자. 스레드는 자주 잠을 잔다(파일 액세스나 다른 컴퓨터에서 결과를 수신하는 등). 이왕 CPU가 놀 것이라면 노는 시간동안 다른 일을 더 처리하도록 하자. 스레드 개수를 더 많이 배정하자. 
- 예를 들어 처리하는 총 시간의 1/4 CPU연산이고 3/4이 잠자는 시간이라면, CPU가 3배더 일할 수 있는 시간이 있다. 이 경우 스레드 개수를 CPU개수의 3배, 즉 24개 배정하는 게 적절하다는 계산이 나온다
1. 어떤 서버의 주 역활이 CPU연산만 하는 스레드라면(즉, 디바이스 타임이 없다면) 스레드 풀의 스레드 개수는 서버의 CPU 개수와 동일하게 잡아도 충분하다.
2. 서버에서 데이터베이스나 파일 등 다른 것에 액세스하면서 디바이스 타임이 발생할 때 스레드 개수는 CPU 개수보다 많아야 한다.

### 1.13 이벤트
- 이벤트는 쉽게 말해서 잠자는 스레드를 깨우는 도구로, 내부적으로 다음 상태 값을 가진다
	- Reset: 이벤트가 없음이라는 의미이다. 정수 값으로 표현하면 0이다.
	- Set: 이벤트가 있음이라는 의미이다. 정수 값으로 표현하면 1이다.
- 수동이벤트와 자동이벤트가 있고, 이벤트에 딱 1회만 상태 값을 1로 바꾸고 즉시 다시 0으로 바꾸는 맥박(pulse)기능도 있다.

### 1.14 세마포어
- 뮤택스나 임계 영역은 오로지 스레드 1개만 자원을 액세스 할 수 있습니다. 하지만 세마포어는 원하는 개수의 스레드가 자원을 액세스 할 수 있게한다.
- 세마포어가 자원 액세스를 단 1개만 허락하게 설정한다면 뮤택스와 다를 바가 없다.
#### 또 다른 용도
- 세마포어는 상태 값을 가지고 있으며, 그 값은 0이상의 정수이다. 초기값은 '최대 액세스 가능한 스레드 개수'이다.
- 스레드가 세마포어에 자원 액세스를 요청하면 상태 값은 1감소한다. 그리고 스레드는 자원 액세스 허가를 받는다. 다른 스레드도 자원 액세스를 요청하면서 결국 상태 값은 0이 된다.
- 스레드 값이 0인 상황에서는 자원 액세스를 허락하지 않기에 스레드가 자원 액세스를 요청하면 그 스레드는 잠자게 된다. 자원 액세스를 마친 스레드는 세마포어에 '자원 액세스가 끝났음'을 통보하고 세마포어의 상태 값은 1 증가시킨다.
- 어떤 스레드가 자원 액세스를 기다리고 있었다면 해당 스레드를 깨운다. 그리고 상태 값은 1감소한다.
- 이벤트와 세마포어는 비슷하다. 이벤트는 상태값을 0과 1만을 가지기에 비정상적인 처리일 때 큐에 항목이 있음에도 이벤트 상태값이 0이 된다. 이 경우 세마포어가 대안이 될 수 있다.

### 1.15 원자조작(atomic operation)
- 뮤텍스나 임계 영역 잠금 없이도 여러 스레드가 안전하게 접근할 수 있는 것을 의미한다. 하드웨어 기능이며, 대부분의 컴파일러는 원자 조작 기능을 쓸 수 있게 한다.
- 대표적으로 다음과 같은 것이 있다.
	- 원자성을 가진 값 더하기
	- 원자성을 가진 값 맞바꾸기
	- 원자성을 가진 값 조건부 맞바꾸기
- 여기서 원자성을 가진 값 더하기란 "변수에 무슨 값이 있는지는 모르지만, 그 값에 특정 값을 더하고 그 값의 결과를 얻어 온다"는 의미이다.
```c++
volatile int a = 0;
```
- 근데 왜 "그냥 값을 넣어라"는 기능이 없을까요?
	- 지금 가져온 값이 로켤 변수로 존재하는데 a는 계속해서 가져온 로컬 변수 값을 보장할 수 없다.
		- a의 주소에서 매번 액세스하면 되지 않을까?
			- CPU와 컴파일러는 코드 최적화와 실행 속도 극대화를 위해 내부적으로 복잡한 일을 한다. 캐시 처리나 실행 순서 변경 등을 예로 들 수 있다. 이러한 문제가 없다고 하더라도 잠금의 전염성 문제도 있다.
### 1.16 멀티스레드 프로그래밍의 흔한 실수들
1. 읽기와 쓰기 모두 잠금하지 않기
2. 잠금 순서 꼬임
3. 너무 좁은 잠금 범위
	- 잠금 객체 범위가 너무 넓으면 컨텍스트 스위치가 발생할 때 운영체제가 해야 할 일이 매우 많아진다.
4. 디바이스 타임이 섞인 잠금
	- 콘솔 출력 함수는 사실 운영체제 안에서 꽤 무거운 일을 한다. (통상적인 게임 로직보다 더 많은 시간을 차지한다). 디버깅 목적으로 콘솔 출력을 뿌릴 때가 있는데, 이때 게임 서버의 메모리 영역에 잠금을 하는 사람이 있을 수 있다. 그런데 이 과정에서 서버 처리를 할 때 병목 현상이 발생한다. 
5. 잠금의 전염성으로 발생한 실수
	- 잠금으로 보호되는 리소스에서 얻어 온 값이나 포인터 주소 값 등이 로컬 변수로 있는 경우에도 잠금 상태를 유지해야 할 때가 있다. 이를 잠금의 전염성이라고 한다.
cf. 합성 가능성의 부족(lack of composability)이란?
-  송금하는 프로그램이 A의 변수를 차감하고 B의 변수를 차감한 만큼 증가시키는 경우가 있다. A가 뮤텍스 잠금으로 안전하게 보호되고 B도 마찬가지더라도, 송금 과정에서 오작동할 수 있다. 이러한 문제를 해결하려면 사용자 A와 B를 한꺼번에 모두 보호하는 뮤텍스 보호 잠금을 하든지, A와 B의 잠금을 모두 한 후에 송금처리 해야 한다. 이렇게 여러 모듈이나 로직을 쉽게 조합할 수 없는 것을 합성 가능성의 부족이라고 한다.
6. 잠금된 뮤텍스나 임계 영역 삭제
	 - 뮤텍스나 임계 영역의 파괴자 함수안에 "이미 잠금하고 있으면 오류를 내라"라는 기능을 추가하면 쉽게 감지할 수 있따.
7. 일관성 규칙 깨기
cf. 공룡 운영체제 책을 보면 컨텍스트 스위치나 타임 슬라이스에 대해 잘 알 수 있다.

