## 5장. 게임 네트워킹
### 5.1 UML
### 5.2 게임 플레이 네트워킹
#### 5.2.1 모든 역할은 서버에서 하기
- 서버가 멀리 있으면 네트워킹 중에 레이턴시가 추가된다.
- 클라우드 서버 안에서 가상 머신은 다른 가상 머신이 CPU 사용량을 잠식하면서 조금씩 지연 시간이 있을 수 있다.
- 패킷 드롭으로 인한 재송신은 간헐적인 큰 지연 시간을 일으킨다
- 인구가 낮은 국가에서는 인터넷이 느리다.
- 무선 네트워크에서는 레이턴시와 패킨 드롭률이 크게 증가한다.
- 또한 서버 운영의 경제성도 있다.
	- 고퀄리티 그래픽을 60프레임으로 랜더링할 때, 서버에서 이것을 하려고 하면 일반 PC수준에서는 고작 4 ~ 5 플레이어 밖에 처리할 수 없다.
	- 일반적인 MMORPG에서 서버컴퓨터는 플레이어 처리를 2000 ~ 20000개까지 해야 제대로 경제성이 나온다

#### 5.2.2 렌더링은 클라이언트에서 하기
- 서버는 렌더링을 위한 최소 정보인 게임 월드 상태만 클라이언트에 보낸다. 월드 상태의 연산은 서버에서 한다.
- 렌더링은 클라이언트에서 수행한다. 이를 위한 그래픽 리소스는 클라이언트에서 보유한다.
- 서버와 클라이언트의 월드 상태를 동일하게 유지한다. 즉, 동기화한다.
```c++
즉, 월드의 변화 정보를 서버에서 보내준다. 플레이어 이동과 지형 충돌 판단, 공격과 방어 판정, 능력치에 대한 계산 결과 판정 등 
게임 플레이 연산은 모두 서버에서만 합니다. 클라이언트에서는 어떤 판단도 하지 않습니다. 심지어 로컬 플레이어가 채팅 메시지를 입력해도,
그것이 서버로 전송된 후 서버에서 "표시하라."라는 응답이 오기 전까지는 자기가 말한 것조차 표시되지 않을 것입니다.
```
- 지금까지 말한 방식이 효과적으로 작동하려면 다음과 같이 해야 한다.
	1. 서버에서는 1/60초마다 월드 상태를 업데이트한다.
	2. 서버는 1/60초마다 월드 상태의 변화를 클라이언트에 보낸다.
	3. 클라이언트는 이를 지체없이 받는다.
	4. 클라이언트는 받은 것을 자기의 월드 상태에 반영한다. 그리고 다음 렌더링 프레임에서 이를 그린다.
- 하지만 현실적으로 월드에드에 케릭터가 매우 많으면 수신하는 데이터 양도 부담이 될 수 있다. 따라서 1/60초마다 보내는 것이 가능한 경우가 많지 않다.
	- 그럼 1/30, 1/10초마다 월드 변화를 클라이언트에 알리면 어떨까?
		- 케릭터의 움직임이 딱딱해진다.
			- 상태값 보정을 통해 서서히 변화시킨다.
				 - 이렇게 부드럽게 하는 방법을 선형 보간(lerp, interpolation)이나 스플라인(spline)같은 곡선형 보간이라고 한다.
				 	- 이런 방식도 레이싱 게임이나 FPS게임의 경우에 문제가 된다.
						- 추측항법을 통해 상대 케릭터의 위치 정보를 이미 지난 약간의 시간만큼 예측해준다.
						- 타깃은 일정한 속도로 이동을 하다 가끔 약간의 거리를 워프한다. 팔로워는 타깃을 향해 이동하다가 워프를 하면 방향을 바꾸어 다시 이동을 하게 하면 된다. 추측 항법을 포함한 이러한 방법을 통틀어 레이턴시 마스킹(latency masking)이라고 한다.
#### 5.3 레이턴시 마스킹
- 위에서 말한 대로 만들고 실제로 플레이를 해보면, 인터넷 환경이 빠르지 않을 때 사용자는 답답함을 느낀다. 움직임에 약간의 지연이 있기 때문이다. 이 문제를 해결하는 법 중 하나는 '사소한 것들은 클라이언트에서 판단하기'이다. 플레이어 자신이 조종하는 플레이어 케릭터의 위치 계산은 클라이언트에서 판단하고, 클라이언트는 판단 결과를 서버에 보내주는 것이다.
- 하지만 단점도 따른다. 클라이언트가 해킹되어서 사용자의 움직임을 무척 빠르게한다면?
	- 클라이언트는 플레이어 케릭터 이동 정보를 서버에 보낸다.
	- 서버는 이동 정보가 정상적인 값 범위에 있는지 검사한다.
	- 또는,
	- 클라이언트는 케릭터 명령 정보를 서버에 보낸다. 클라이언트는 일방적으로 움직이지만, 케릭터 이동 메시지는 서버에 보내지 않는다.
	- 서버는 명령 정보에 따라 케릭터를 이동 처리한다. 클라이언트는 서버에서 이동 정보를 받으면, 앞서 일방적으로 움직였던 케릭터 위치를 무시하고 서버에서 메시지에 따라 케릭터를 움직인다.
- 두번째 방법이 해킹을 막는데 좋지만, 레이턴시가 100밀리초를 넘을 때마다 케릭터 움직임이 손상된다.
- 레이턴시 마스킹을 위한 또 다른 테크닉 중 '단 보여주고 나중에 얼렁뚱땅하기' 방법도 있다.
	- 플레이어가 어떤 행동을 하면 행동 명령에 대한 메시지를 서버에 보낸다. 동시에 행동을 연출하는 일부 모습을 클라이언트에서 즉시 시작한다.
	- 서버에서 행동 명령을 ㅁ받아 처리하고, 플레이어 케릭터에 가해야 하는 행동을 클라이언트에 메시지로 보낸다
	- 클라이언트는 이 메시지를 받으면 연출해야 하는 나머지 부분들을 클라이언트에서 보여준다.
	- 디아블로 3, 레이턴시가 없을 때는 케릭터가 공격을 하면 바로 이펙트 발생. 레이턴시가 높을 땐 공격 모션만 취할뿐 이펙트는 좀 더 늦게 나온다. (그래도 플레이어 입장에서는 일단 공격행동이라도 보여주는게 심리적으로 더 좋다고 느낀다) , 스타크래프트도 유닛을 이동시키면 목소리로는 즉각 반응하지만 바로 움직이지 않는 것처럼.
#### 5.4 넓은 월드, 많은 케릭터 처리
- MMORPG에서 1km 이상 떨어져 있는 플레이어는 잘 보이지도 않는다. 즉 모든 걸 다 보내줄 필요는 없다.
- 서버에서는 다음 정보를 가지고 있어야 한다.
	- 플레이어 각각에 대해서 각 플레이어가 볼 수 있는 케릭터 목록
	- 케릭터 각각에 대해서 자기 자신을 볼 수 있는 플레이어 목록
#### 실시간 전략 시뮬레이션 게임에서 네트워크 동기화
- 플레이어 수가 적음에도 케릭터 수가 많기 때문에 지금 까지 알아본 방식으로 네트워크 동기화를 할 경우 등장하는 통신량이 늘어난다. 이 경우 락스텝(lock step) 동기화 알고리즘을 사용하는 것이 좋다.
- 락스텝 동기화 방식
	- 모든 기기에서 상대방에게 1/60초마다 메시지를 보내며, 모든 기기에서 메시지가 온 후에야 게임 월드를 업데이트 한다. 메시지 내용은 "현재 시간, 가한 명령, 체크섬"이 된다.
	- 이런 작동 방식을 사용하여 수 많은 케릭터를 조종하는 게임이라 하더라도 정확한 움직임을 표현할 수 있다. 그러나, 이 방식은 컴퓨터 간 통신 레이터신가 거의 없을때라야 완벽하게 작동한다는 한계가 있다.
	- 이를 해결하려면 입력 명령을 보내되 '언제 실행해야 하는지에 대한 미래 시간'을 같이 보내야 한다.
	- 미래 시간은 다음과 같이 산정하자
		- 현재 시간 + 왕복 레이턴시(RTT) / 2 + 임의의 일정 값
		- 미래 시간은 너무 멀다면, 플레이어가 케리터에게 명령을 주고 그 명령을 실행하기까찌 매우 오래 걸린다. 즉, 렉을 느낀다. 반대로 너무 가까우면 게임 플레이 화면이 중간중간 멈춥니다.(케릭터의 움직임이 중간중간 튀는 stuttering 현상)
		- 전략 시뮬레이션 게임에서 다음과 같이 레이턴시 마스킹을 하기도 한다
			 - 실제로 케릭터 입력 명령을 처리하지 못했더라도 명령에 반응하는 연출만 보여준다! (오 즉시 반응하는군!"
			 - 이후 미래 시간에 도달하면 실제로 케릭터가 움직이게 한다.
- 락스텝 동기화 알고리즘은 많은 케릭터가 적은 통신량으로도 정확히 동기화된다는 장점이 있지만, 한계도 있다.
	- 다른 플레이어가 플레이하고 있는 게임 중간에 확 들어오는 것을 만들기 까다롭다
	- 물리 엔진 등 게임 플레이에 관여하는 연산에 부동소수점을 쓸 수 없다. 부동소수점 연산은 하드웨어 종류에 따라 연산 결과가 미세하게 차이가 날 수 있는데 이것이 마치 나비효과처럼 큰 차이로 어어진다. 따라서 이 문제를 해결하려면 게임 플레이에 관여하는 연산은 모두 고정소수점으로 해야 한다. 최악의 경우 물리 엔진을 고정소수점 기반으로 다시 만들어야 할 수도 있다.
- 플레이어 수가 많아지기 어렵다.
- 씬 업데이트가 일시정지할 확률이 높다. 원활하게 플레이하려면 함께 하는 플레이어 중 가장 레이턴시가 높은 사람을 기준으로 미래 시간이 결정되어야 하기 때문이다.
- 입력 명령의 속도에 민감한 게임에 부적합합니다. 필연적으로 플레이어 케릭터는 미래시간이 되어야 움직이기 때문이다. 그래서 방향키로 직접 이동하는 방식에 이 알고리즘을 적용하면 게임 플레이가 매우 답답하게 느껴진다
#### 5.6 실제 레이턴시 줄이기
- TCP 대신 UDP를 사용하는 것도 한 방법이다.
- 패킷 유실 상황에서 TCP는 패킨 재전송을 위한 지연 시간이 발생한다.
- 똑같은 양의 데이터를 보내도 가급적 적은 수의 패킷으로 뭉쳐서(coalescence) 보내면 효과적이다. 필자 경험상 뭉치는 시간은 10밀리초 이하가 적당하다.
- 클라이언트와 서버 간 통신과 클라이언트끼리 직접 통신하는 것을 같이 섞어 쓰는 방법도 좋다. 전자는 C/S 네트워킹이라고 하며 후자는 P2P네트워킹이라고 한다. 가급적 많은 지역에 게임 서버를 고루 분포시킨 후 플레이어들을 자신과 가장 가까운 지역의 게임서버에 접속해서 게임을 플레이하면 굳이 이렇게하지 않아도 된다.
- 하지만, 이런 방식이 힘들 경우 두 가지 네트워크 방식을 혼용하는 게 좋다. 전투 판정 같은 중요한 연산은 C/S네트워킹과 서버에서 연산으로 처리하고, 플레이어 케릭터 이동이나 채팅처럼 덜 중요한 연산은 P2P 네트워킹과 클라이언트 연산으로 처리한다. 두 클라이언트는 서로 가깝지만 서버가 멀리 있을 때 이 방식이 효과적이다.

#### 5.7 게임 플레이 이외의 네트워킹
- 게임을 시작하면 로그인 과정이 나온다. 이 과정에서 클라이언트와 서버가 대화하는 절차는 다음과 같다.
	1. 로그온 요청 메시지를 서버로 전송한다.
	2. 서버는 파일이나 데이터베이스에서 해당 유저의 ID와 비밀번호를 받아서 식별한다.
	3. 식별 결과, 즉 로그온 처리 결과를 클라이언트에 통보한다.
	4. 클라이언트가 이 통보를 받으면(로그온 성공 이라는) 플레이어 정보를 데이터베이스에 로딩해서 게임 서버 메로리에 보관한다. 이 과정은 없을수도
- 온라인 게임을 개발할 때 컴퓨터 간에 어떤 대화가 있는지 시퀀스 다이어그램(sequence diagram)을 그리면서 하는 것이 좋다
	- (우와, 책에 나오는 시퀀스 다이어그램 멋지다..)
- 플레이어가 수동으로 방을 만들고, 다른 플레이어가 수동으로 방에 들어가는 방식을 설계
	1. 해킹을 방지하고자 방 만들기 혹은 들어가기 정보는 클라이언트에서 판단하지 말고 서버에서 모두 판단할 것
	2. 클라이언트에서는 일방적으로 판단하지 말고 서버에 요청하여 그 결과에 따라서 행동할 것
	3. 방 만들기 혹은 방 들어가기로 서버 내부의 방 목록이나 방 안의 플레이어 목록이 변할 때 클라이언트는 그 변화를 통보받을 것
- 게임 로직을 개발하는 과정에서 서버와 클라이언트가 어떤 대화를 나누어야 할지는 내가 원하는 대로! 단 가장 기본적인 규칙이 있다.
	1. 클라이언트에서는 요청을 보냅니다.
	2. 서버에서 그 요청을 받아 결과를 판단합니다.
	3. 요청 결과에 영향을 받을 다른 클라이언트가 서버에 있으면 그 클라이언트에 통보합니다.
- 아이템 사용 처리를 위한 액티비아 다어어그램(거시적인 흐름 -> 시퀀스 다이어그램, 세부적인 로직 -> 액티비티 다이아그램

#### 5.8 해킹과 보안
- 해킹
	- 크래킹(crack): 다른 사람의 ID와 비밀번호를 도용하거나 비밀 정보를 보는 것을 의미한다. 서버에 저장된 데이터를 훼손하거나 훔치는 것도 포함.
	- 치트(cheat) 혹은 조작(exploit): 게임에서만 발견되는 형태의 해킹이다. 내 능력치를 비정상적으로 높이거나 다른 사람의 플레이를 망가뜨리는 것을 의미.
- 네트워크 해킹
	- 평문(암호화하기 전 데이터), 암호 키(일정한 크기의 바이너리 데이터), 암호문(암호화한 후 데이터, cipher)
	- 평문 + 암호키 -> 암호문
	- 암호문 + 암호키 -> 평문
	- 그런데, John과 서버간의 암호 키를 Alice(해커)가 모르게할까?
		- 암호 키를 2개를 두는 것이다.
		- 평문 + 암호키 1 -> 암호문
		- 암호문 + 암호키 2 -> 평문
		- 암호와 알고리즘은 이렇게 작동한다.
			1. 서버에서 암호 키 1을 John에게 보낸다.
			2. John은 암호 키를 만들어 서버에 보낸다. 그냥 보내지 않고, 암호 키 1로 암호화해서 보낸다.
			3. 서버는 이것을 받아서 암호 키 2로 복호화한다. 그리고 john이 보낸 암호키를 얻는다.
			4. John은 ID와 비밀번호를 암호 키로 암호화하여 서버에 보낸다.
			5. 서버는 앞서 받았던 암호 키를 이용해서 복호화한다. 그러면 ID와 비밀번호를 얻을 수 있다.
		- Alice의 해킹
			1. 암호화 알고리즘 1의 과정에서 암호 키 1을 훔친다.
			2. Alice는 암호화 알고리즘 2의 과정에서 암호화된 암호 키를 훔친다. 그러나 암호 키 2가 없으므로 복호화할수 없다.
			3. Alice 암호화 알고리즘 4의 과정에서 암호화된 ID와 PW를 훔친다. 그러나 마찬가지로 암호 키가 없으므로 복화할 수 업삳.
			- 결과적으로 alice는 암호 키 2가 있어야 한다. 암호키 2를 찾는건 현실적으로 불가능하다.
	- 암호 키: 대칭 키(symmetric key) 혹은 세션 키(session key)라고 한다.
	- 암호 키1: 공개 키(public key)
	- 암호 키2: 개인 키(private key)
#### 클라이언트 컴퓨터 해킹
#### 서버 컴퓨터 해킹

