## 7장. 데이터베이스 기초
### 7.1 플레이어의 정보 저장
- 플레이어 정보를 서버에 저장하는 방법
	- 파일
	- 데이터베이스
- 파일과 데이터베이스 비교

|                                                              | 단순파일 | 데이터베이스 |
|--------------------------------------------------------------|----------|--------------|
| 소프트웨어 비용                                              | 없다     | 없거나 높다  |
| 저장 및 로딩 속도                                            | 빠르다   | 느리다       |
| 데이터 관리, 분석 속도                                       | 느리다   | 빠르다       |
| 데이터 백업 및 복원 기능                                     | 없다     | 있다         |
| 원자성(데이터 2개이상 전부 변경 하고자 할 때 전부 혹은 전무) | 불가능   | 가능         |
| 일관성                                                       | 없다     | 있다         |
| 고립성(경쟁 상태부터 자유롭게 해주는 기능)                   | 없다     | 있다         |
| 지속성(장애 직전의 상태로 복구가능한지)                      | 없다     | 있다         |

### 7.2 데이터베이스 사용
### 7.3 데이터베이스의 데이터 구성
- 표(table) 형태의 집합이다.
- 테이블의 집합은 데이터베이스 인스턴스라고 한다. 데이터베이스가 다루는 가장 큰 단위의 데이터 집합이다.
- 데이터베이스 인스턴스 안에는 테이블이 1개 이상 들어간다. 테이블은 기본적으로 표 형태며 당연히 행과 열이 잇다.
- 데이터베이스에서는 행 단위로 데이터를 넣거나 뺄 수 있다. 이 행을 레코드(record)라고 한다.
- 또 레코드 안에는 표의 열이 있는데 이를 필드(field)라고 한다. 필드는 이름 말고도 타입이라는 것을 추가로 가지고 있다. (타입: 정수, 소수, 문자열, 날짜와 시간 등)
### 7.5 SQL 질의 구문
- 데이터베이스에 엑세스할 때 필수적으로 알아야 할 문법은 질의(SQL query)이다.
- 레코드 추가하기, 읽기, 변경(업데이트), 삭제하기 입니다. 각각을 CRUD(Create, Read, Update, Delete)라고 한다.
```sql
CREATE TABLE Players
(
	UserID nvarchar(50) NULL,
	Password nvarchar(50) NULL,
	Score int NULL
)
GO

// 새 레코드 삽입
insert into table1 (a,b,c) values (1,2,3)
// table1에 필드 a = 1, b = 2, c = 3이 들어 있는 새 레코드를 하나 추가하는 내용

// table1에 모든 레코드를 얻으려면 select 구문을 사용하자
select a,b,c from table1 where a=1

// table1에서 필드 a가 1인 레코드를 찾는다. 그리고 그것의 모든 필드를 얻는다.
select * from table1 where a=1

//table1에 있는 레코드 중 필드 a가 1인 레코드를 찾아 필드 b를 2로 변경한다.
update table1 set b=2 where a=1

//table1 에 있는 레코드 중 필드 a가 1인 것을 모두 삭제한다.
delete from table1 where a=1
```
### 7.6 인덱스와 키
- 인덱스는 필드 단위로 설정할 수 있다. 
- 인덱스는 select 구문, 즉 검색만을 위한 것이 아니다. 기존 레코드를 변경하거나 레코드를 삭제할 때도 인덱스는 빨리 찾는데 도움이 된다.
- 인덱스는 빠른 검색 용도뿐만 아니라, 중복된 값을 방지하는 용도로도 사용한다. 인덱스에는 유니크(unique)라는 속성을 추가로 지정할 수 있다.
- 하지만 데이터베이스에서도 인덱스에 걸쳐 있는 레코드가 변화가 일어 날 때, 인덱스도 같이 업데이트해야한다.
- 프라이머리 키(primary key)가 있다.
	- 한 테이블에 하나만 추가할 수 있다.
	- 중복을 허락하지 않는다. 즉, 한 테이블에 값이 같은 코드가 2개 이상 들어갈 수 없다.
	- 필드 값은 null이 허락되지 않는다.
### 7.7 플레이어 정보를 데이터베이스에 저장하는 방법 1
1. 플레이어 데이터 전체를 문서 형태로 만들어서 테이블에 넣는다.
2. 플레이어 데이터를 구성하는 트리 노드 각각을 테이블에 넣는다.
- 플레이어 정보를 JSON 형태로 하나로 만든 후에 테이블에 저장한다.

### 7.8 플레이어 정보를 데이터베이스에 저장하는 방법 2
- playerID는 서로 중복되지 않게 하자. 유니크 속성이 들어있는 인덱스를 추가해주던가 ID 필드에 프라이머리 키를 설정한다.
- 어떤 테이블을 넣어야 할지 계획을 잡을 때 자주 사용하는 방식은 외래 키(foreign key)를 사용하는 것이다.
- 플레이어 케릭터를 저장할 때 고유 이름 ID 뿐만 아니라 "이 플레이어 케릭터가 누구의 소유인가?도 저장하는 게 좋다.
- 플레이어가 A와 B를 가지고 있을 때 Plaer ID는 핃르를 가리키는 외래키가 된다. 외래키는 중복을 허용ㅇ하므로 논 유니크 인덱스로 설정한다.
	- 트리의 각 노드는 테이블의 레코드가 된다
	- 각 노드의 소유자, 즉 부모 노드는 외래 키가 된다.
### 7.9 질의 구문 실행
```c++
select ID, password from UserAccount where ID='Hong Gil Dong'

select * from Character where ID='Little Elf'

select * from Item where OwnerCharacterID='Little Elf'

update Character set Exp=2943 where ID='Little Elf'

insert into Item (ID, OwnerCharacterID,Type,Amount) values (37485, 'Little Elf, 34, 3)

update Item set Amoun=2 where ID=37485

delete from Item where ID=37485
```

- 저장 프로시저(stored procedure) : 데이터 베이스 측에 미리 질의 구문 집합을 저장.

#### 7.91 트랜젝션
- 구문을 실행하다가 뭔가 잘못된거 같다고 판단되면 commit 대신 rollback transaction을 실행한다. 그러면 begin transaction을 구문을 실행한 후 원상복귀 된다.
1. 트랜잭션을 걸고 액세스하는 레코드는 멀티스레드 프로그래밍에서 뮤텍스를 잠금한 것과 비슷하다
2. 트랜잭션을 걸고 액세스하는 레코드는 다른 질의 구문 세션에서 액세스하면 앞서 트랜잭션이 완료되거나 취소될 때까지 블로킹이 걸린다
- 데이터베이스 트랜젝션을 할 때는 꼭 필요한 최소한의 구간에서만 하는 것이 좋다. 트렌잭션의 영향을 받는 레코드는 최소 개수로 하고, 트렌잭션을 시작부터 끝날 때까지 데이터를 액세스하는 횟수 역시 최소로 하는 것이다.
- 교착 상태로 질의 구문 실행이 매우 오랫동안 블로킹 되거나 실패를 출력할 때도 반드시 예외처리를 해주어야 한다.
- 트랜잭션이 관여되는 레코드는 다른 질의 구문 프로세스에서 액세스할 경우 블로킹을 일으켜 병렬 처리 효율성이 떨어진다. 불행하게도 트랜잭션 관련 레코드만 잠금되는 것이 아니라, 주변에 있는 다른 레코드 또는 해당 레코드가 있는 테이블 전체가 잠금 되기도 한다.
- 게임 서버는 플레이어 정보를 메모리에 보관하고, 플레이어의 데이터를 게임 서버 안에 있는 메모리에서 변경하며, 변경된 내용을 데이터베이스에 저장한다. 즉, 데이터베이스를 세이브 데이터처럼 사용하는 것이다.
- 게임 서버 메모리에서 사전 검증을 다 해버리는 특성 때문에 트랜젝션이 꼭 필요한 상황은 적다. (중간에 크래시 나는 위험성은 있음)
	- 트랜젝션으로 발생하는 성능 저하와 데드락 가능성을 완전히 없애고 싶다면
		- 어딘가에 로그를 남겨 놓고 플레이어의 레코드를 업데이트. 업데이트 완료되면 로그를 지우는 것
		- 트랜젝션에서 발생하는 잠금 수준 완화. (데이터 베이스 ACID 특징 다소 위반, 그대신 효과는 좋다)
#### 7.1 게임 서버에서 질의 구문 실행
#### 7.11 보안을 위한 주의 사항
