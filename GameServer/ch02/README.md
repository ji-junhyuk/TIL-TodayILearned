### 2.1 컴퓨터 네트워크를 구성하는 기기
- 컴퓨터 네트워크는 크게 단말기(terminal)와 네트워크 기기로 구성된다. 여기서 단말기란 통신을 하는 주체를 지칭한다.
- 단말기에는 컴퓨터, 스마트폰 등이 포함된다.
- 단말기는 클라이언트와 서버로 구분한다. 클라이언트는 사람이 많이 만지는 컴퓨터를 의미하며 서버는 많은 사람이 만지는 단말기에 서비를 제공하는 무인 컴퓨터를 지칭한다.
1. 링 위상(ring topology) 통신
- 맨 앞에 학생이 맨 뒤의 학생에게 쪽지를 전하는 것처럼 전달하는 방식
2. 네트워크 기기(network device) 통신

#### OSI 모델(Open Systems Interconnection reference)
- 컴퓨터 네트워크 통신에 대한 국제 표준이다.
1. 계층1: 물리 계층 (하드웨어)
2. 계층2: 데이터 링크 계층(로컬 지역 네트워크LAN에서 통신을 가능하게 한다)
3. 계층3: 광역 통신망(WAN)
4. 계층4: 전송 계층(반드시 상대방에게 데이터가 도착하게 한다)
5. 계층5: 세션 계층, 계층 6: 표현계층, 계층 7 응용계층
- 응용프로그램이나 운영체제 안 모듈이 다른 컴퓨터의 응용 프로그램이나 웅영체제 모듈과 통신을 하는 동안 논리적 연결 단위나 기능들을 여기서 다룬다. (MPEG, SSL, HTTP 등이 있다)
#### 계층 2
- 각 단말기는 고유한 주소를 갖는다.
- 단말기는 데이터를 프레임(frame)이라는 단위로 주고 받는다.
	- 단말기가 보내고자 하는 데이터(payload), 수신자와 송신자(header), 이 둘을 합쳐 프레임(frame)이라고 한다.
- LAN과 LAN을 연결한 것을 광역통신망(Wide Area Network, WAN)이라고 한다.
#### 계층 3
- 우체국을 떠올려보자. WAN에서도 직접 데이터를 건네주는 것이 아니라, 계층적으로 데이터를 건네주는 방식으로 작동한다. 이 데이터를 취급할 수 있는 곳으로 데이터를 보내주는 역할을 담당하는 네트워크 기기를 라우터(router)라고 한다. 라우터는 서로 다른 LAN 사이에 컴퓨터 통신을 할 수 있게 하는 장비이다.
- 계층 3에서 흔히 접하는 인터넷 프로토콜(Internet Protocol) 혹은 IP라고 하는 것이다.
- 단말기 A에서 데이터 X를 다른 단말기 B로 보내려고 하면, 데이터 X는 OSI 모델 계층 3의 인터넷 프로토콜에 의해 IP 패킷(packet)형태로 포장된다. A와 B가 같은 LAN이면 스위치를 거쳐 단말기 A로 간다. 다른 LAN에 있을 땐 X는 LAN에 연결된 라우터를 통해 다른 LAN으로 간다.
cf. IP 패킷에는 주고 받는 데이터, 즉 페이로드의 크기와 송수신자 주소, 체크섬 등이 있다.
### 2.3 컴퓨터 네트워크 데이터
- 계층 2에서는 데이터 단위를 프레임이라 했고, 계층 3에서는 패킷이라고 했다. 그렇지만 네트워크나 서버 앱을 개발할 때는 이를 직접 다룰 일이 흔하지 않는다. 그 대신 스틈과 메시지라는 것을 주로 다룬다.
#### 스트림 형식
- 스트림(stream)이란 데이터의 흐름이다. 두 단말기를 연결한 후 그 연결을 끊기 전까지 한쪽에서 다른 한쪽으로 연결된 데이터 흐름 하나를 일컫는다. 스트림 안에 데이터를 중간에 끊는 것은 여러분의 몫이고, 스트림 자체는 데이터를 중간에 구별하지 않는다.
- 단말기 A에서 스트림 형태로 송신하고, B에서 그 스트림을 수신한다. 이때 단말기 A에서 스트림에 넣은 데이터가 단말기 B에서 꺼낸 것과 완전히 같지 않을 수 있따. 하지만 단말기 A에서 보낸 것을 모두 이어보면 단말기 B에서 꺼낸 것을 이은 것과 같다!
- 데이터를 보내기 전에 헤더를 붙이는 방식과 구분자를 이용하는 방식을 선택한다.
#### 메시지 형식
- 스트림과 달리 메시지는 자체적으로 데이터의 시작과 끝을 구별할 수 있다.
- 여러 필드로 나누어 사용한다.
- IP 패킷의 크기는 제한적이었지만 스트림이나 메시지에는 이러한 제한이 없다. 운영체제에 내장된 네트워크 모듈인 네트워크 스택에서 스트림과 메시지를 관리해주기 때문이다.
- 매우 긴 스트림을 송신할 때 운영체제는 이를 IP패킷의 크기 제한에 맞추어 조각을 낸다. 이를 단편화(fragmentation)라고 한다.
### 2.4 컴퓨터 네트워크 식별자
- 단말기마다 ip주소가 있다. 하지만 이것만으로 네트워크 프로그램을 개발하기에는 부족하다. 단말기 안에서 작동하는 프로세스는 여러 개인데, 이중 누가 보낸 것인지 모르기 때문이다. 또 받는 쪽에서도 보낸 데어터를 어느쪽으로 받아야할지 식별해야 한다. 즉, 한 ip 주소 안에서도 누가 주고받는 것인지를 식별을 역활하는 것이 포트(port)이다.
- ip주소를 보고 싶다면 ipconfig, 사용 중인 포트를 보고 싶다면 netstat -ano
- <ip주소:포트>형식에서 ip주소와 포트를 한데 묶어 끝점(endpoint)라고 한다.
- 모든 기기에 ip주소만 있으면 사람이 불편하다. 따라서 영어 문장 형식을 입력하면 이를 ip주소로 변환하는 것이 보편화되어 있다. 이때, 입력하는 영어 단어 형식의 기기 주소를 호스트 이름(host name)이라고 한다.
- 호스트 이름을 ip주소로 변환하는 역할은 도메인 이름 서버(DNS Server)에서 담당한다.
### 2.5 컴퓨터 네트워크 품질과 특성
- 스위치나 라우터에 자신이 처리할 수 있는 한계를 넘는 데이터가 수신된다면?
	1. 자리가 처리할 수 있는 것 이상을 그냥 버린다.
	2. 아직 처리하지 못한 것들을 메모리에 누적한다.
- 라우터에 과부하가 걸리면 송신자가 보낸 패킷 중 일부는 수신자에게 전달하지 못하는 패킷 유실 현상이 발생한다. 이는 라우터 때문 만은 아니고, 데이터가 오가는 선로에 문제가 있을수도 있다.
- 기본적으 데이터는 유선이나 무선 회선으로 나가는 과정에서 일정 진폭이나 주파수의 전기 신호나 전자기파 신호로 변경되어 방출된다. 즉, 디지털 정보를 아날로그 신호로 바꾸는 것이다.
- 수신자는 아날로그 신호를 받으면 진폭, 주파수 등을 파악하여 디지털 정보로 바꾼다. 그리고 이를 OSI모델의 계층 2 처리 모듈로 넘기고 이후 계층 3 모듈로 넘어간다. 이 과정에서 아날로그 신호에 변화가 생길 수 있다. (잡음이 섞이거나, 신호가 약해질 수 있다) 이떄, 수신한 데이터에서 오류가 발생하면 계층 2나 계층 3의 체크섬 검사로 확인할 수 있고 발견되면 수정을 시도한다. 수정하기 어려우면 받은 패킷 혹은 프레임을 그냥 버린다.
- 라디오로 방송을 들을때 무선감도가 좋지 않으면 지지직 소리가 나는 것. 또는 음성 대화를 할 때 소리가 늦게 도착하거나 끊기는 경우. 유선이든 무선이든 신호가 불량하면 도착한 패킷의 체크섬이 달라 버려지는 것이 많아서 그런 것이다.
#### 전송 속도와 전송 지연시간(latency)
- 전송 속도(스루풋throughput, 처리율 이라고도 한다)
	- 초당 비트 수 혹은 바이트 수로 표현한다.(bits per second, bps / Bytes per second, B/s) 
	- 선로의 종류와 품질, 두 기기의 소프트웨어와 하드웨어 종류에 따라 전송 속도에 영향을 준다.
- 레이턴시
	- 두 기기 간 데이터를 최소량 전송할 때 걸리는 시간, 단위는 밀리초(ms)
	- 매체의 종류와 품질, 송신자-수신자 사이의 라우터 처리 속도가 레이턴시에 영향을 준다.
- ex) ping www5.usp.br
	- 300ms 정도 나온다. 한국과 남미 사이의 거리는 약 2만km, 70밀리초 정도가 나와야 하는데 오차가 생긴 이유
	- 데이터가 매체를 통과하는 시간보다 네트워크 기기 안에서 처리하는 시간이 훨씬 길기 때문이다.
	- tracert ww5.usp.br 로 경로를 추적해보자. 약 17개 정도가 나오는데, 각 네트워크 기기를 지날 때마다 각가의 레이턴시가 누적된다. 가장 느린 곳의 속도가 50이라면, 여기가 병목이고 50이 최종 속도로 결정된다.
#### 네트워크 품질 기준 세가지
1. 전송 속도(스루풋)
	- 회선의 종류가 좋을수록, 네트워크 장비 처리속도가 빠를수록 향상
2. 패킷 유실률
	- 회선 품질이 좋을수록, 경로에 있는 라우터 개수가 척을수록, 라우터의 처리 성능이 좋을수록 낮다.
3. 레이턴시
	- 회선 길이가 길수록, 경로에 라우터 개수가 많을수록 높다.

#### 와이파이에서 데이터를 전송할 때의 동작
1. 데이터를 전파로 변환하여 보내기 직전에 안테나를 통해 다른 전파가 감지되는지 확인한다.
2. 전파가 감지되는 것이 없으면 전파를 보낸다.
3. 전파가 감지되면 잠시 기다렸다가 1~2 과정을 반복한다.
4. 신호를 보낸 후 상대방에게서 '신호를 받았음' 응답이 오는지 체크한다
5. 응답이 일정 시간 동안 없으면 보냈던 신호를 다시 보낸다.
- 이렇게 작동하는 구조를 CSMA(Carrier Sense Multiple Access)라고 한다. 이것이 없으면 기기들이 신호를 보내는 것이 서로 뒤섞여 신호가 변조된다.
### 2.6 컴퓨터 네트워크에서 데이터 보내기와 받기
#### UDP 네트워킹(User Datagram Protocol)
- 사용자가 정의한 데이터그램(datagram)을 상대방에게 보낼 수 있게 하는 통신규약(protocol)이다.
- UDP는 패킷 유실 현상이 발생할 수 있다. (즉 같은 데이터그램을 두번 이상 받을 가능성이 있고, 순서와 다르게 받을 수도 있다. 하지만 데이터그램 내용이 훼손되는 경우는 매우 드물다)
- UDP는 스트림이 아닌 메시지의 성질을 가진다
- 프로그램이 UDP로 데이터를 주고 받으려면 소켓(socket)을 생성해야 한다. 소켓은 단말기 사이에 송신할 수 있게 운영체제에서 제공하는 자원이다.
```c++
main() // <송신자>
{
	s = socket(UDP); // 소켓 핸들을 받기
	s.bind(any_port); // 데이터를 주고 받으려면 포트를 하나 할당해야 하는데, 할당하는 함수로 bind를 호출한다.
	s.sendTo("55.66.77.88:5959", "hello"); // 상대방 주소와 포트, 끝점에 원하는 데이터를 보내면 된다.
	s.close(); // 소캣 핸들이 닫힌다. 할당받은 포트도 다른 곳에서 사용 가능한 상태가 된다.
}

main() // <수신자>
{
	s = socket(UDP);
	s.bind(5959); // 송신자 측에서 명시적으로 지정한 포트번호로 지정
	r = s.recvfrom(); // 데이터를 받고, 데이터가 도착하지 않으면 함수는 리턴하지 않는다.(블로킹 상태) 데이터가 도착하면 데이터와 송신자 주소가 변수 r에 채워진다.
	print(r.srcAddrPort, r.data);
	s.close();
}
```
- UDP 소켓을 이용해 데이터를 송수신하는 게 가능하다. 하지만 송수신용 소켓을 따로 만드는 것 자체를 권장하지는 않는다.
- UDP 는 다대다 통신이 가능하다.
- 사용법이 간단한 반면, 데이터 유실 또는 순서 뒤바뀜 문제가 생긴다는 단점이 있다.
#### TCP 네트워킹(Transmission Control Protocol)
- 보내는 쪽 데이터가 받는 쪽에서 완전히 동일함을 보장해주는 프로토콜이다. UDP는 그저 sendTo(), recvfrom() 함수만 있으면 데이터를 주고받을 수 있었던 반면, TCP는 데이터를 주고 받기전 '연결'이라는 과정을 먼저 해야 한다. 이를 보고 연결 지향형(connection oriented)이라고 합니다. 또 연결은 일대일만 가능하다.
- 연결해야 하는 불편함이 있지만, 그 대신 보낸 데이터가 받는 쪽에서 정확히 모두 도착하는 것을 보장한다. 이런 중요한 특징 때문에 인터넷 프로그램은 대부분 TCP를 사용한다. (TCP의 data flow control, 흐름 제어 기능)
- TCP는 메시지 형태가 아니라 스트림 형태이다.
- TCP에서 보낼 스트림데이터는 세그먼트(segment)라는 IP 패킷에 넣을 수 있는 크기의 단위로 쪼갠다. 그러고 나서 IP 패킷 안에 세그먼트를 넣어서 수신자에게 전송한다. 수신자는 IP 패킷을 받으면 다시 세그먼트 응답을 반송한다. 이 응답을 ack 혹은 acknowledge라고 한다. 일정 시간 안에 ack가 회신되지 않으면, 상대방 응답이 있을 때까지 다시 세그먼트를 보낸다.
```c++
main() <송신>
{
	s = socket(TCP); // UDP가 아닌 TCP 지정!
	s.bind(any_port);
	s.connect("55.66.77.88:5959"); // 연결에 성공할 때까지 블로킹
	s.send("hello"); // sendTo가 아닌 send. 끝점 입력은 connect에서 지정했음.
	s.close();
}

main() <수신>
{
	s = socket(TCP);
	s.listen(5959); // TCP 연결을 받아들이는 역할만 한다.
	s2 = s.accept(); // 상대방에게 TCP 연결을 받을 때까지 블로킹된다. TCP 연결이 받아지면 새로운 socket이 생성되며, socket의 핸들값을 리턴한다.
	print(getpeeraddr(2)); // TCP연결을 맺은 socket의 상대방 끝점을 확인한다. getsocketaddr()을 호출하면 이쪽 끝점 정보가 나온다.
	while (true)
	{
		r = s2.rev(); // 이미 연결상태, 끝점 정보를 넣지 않음
		if (r.length == 0)
			break;
		// UDP와 달리 TCP는 스트림 형식이기에 send()로 0바이트를 보내면 사실상 아무것도 하지 않는다. recv()에서 0바이트를 수신하면 '이는 연결이 종료되었음을 의미한다. (endoffile가 같은 의미이다)
		print(r);
	}
	s2.close();
}
```
