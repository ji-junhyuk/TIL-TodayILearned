### 6.1 상속
- 상속(inheritance)은 객체 단위 코드를 '재사용'하는 방법이며, '재사용'이란 기능적 확장이나 개선을 의미한다. 무엇보다 C++클래스가 C의 구조체와 구별되는 근거이다. 그리고 상속을 이해하는데 가장 중요한 것은 바로 '관계'이다.

#### 기본 문법
```c++
class 파생클래스이름 : 접근제어지시자 부모클래스이름

class CMyData
{
};

class CMyDataEx : public CMyData
{
};
```
```
- 파생 클래스의 인스턴스가 생성될 때 기본 클래스의 생성자도 호출된다.
- 파생 클래스는 기본 클래스의 멤버에 접근할 수 있다. 단, private 접근 제어 지시자로 선언된 클래스 멤버에서는 접근할 수 없다.
- 사용자 코드에서는 파생 클래스의 인스턴스를 통해 기본 클래스 메서드를 호출할 수 있다.
```
### 6.2 메서드 재정의
- 재정의의 영어 원문은 override인데, 사전 의미에는 '무시하다'는 정의가 포함된다. 이는 메서드를 재정의하면 기존의 것이 '무시'되기 때문이다.
- 파생 형식에서 기본 형식의 동일한 메서드를 호출하려면 소속 클래스를 명시해야 한다.
- 재정의한 이유가 기존의 코드를 제거하기 위해서가 아닌 기존의 메서드와 새 메서드를 한 데 묶어 작동하게 하려는 의도임을 이해해야 한다.
#### 참조 형식과 실형식
```c++
CMyDataEx a;
CMyData &r_data = a; // 파생형식을 기본형식으로 참조하는건 매우 자연스러운일. 학생을 사람이라고 부른다거나,
					 // 참조의 원본인 a는 '실제 형식'이고 rData는 '참조 형식'이다.
r_data.set_data(15);
cout << r_data.get_data() << '\n' // 실 형식과 참조 형식이 다른 경우 묵시적인 호출로 어떤 메서드가 호출되는가? 
```
- 실 형식과 참조 형식이 다를 경우 '참조 형식'의 메소드가 호출된다.
- 참조 형식에 있는 포인터도 마찬가지다.
```c++
CMyData *p_data = new CMyDataEx;
p_data->set_data(5);
delete p_data;
// 누수가 있는 코드이지만 set_data로 호출된 함수는 CMyData::set_data()가 호출된다. CMyDataEx의 소멸자가 호출되지 않기 때문!!
```
## CMyData *p_data = new CMyDataEx; // 참조형식 CMyData이다. 동적 생성된 실제 형식이 CMyDataEx임에도 CMyDataEx::SetData가 호출된다

### 6.3 상속에서의 생성자와 소멸자
- B가 A를 상속하고 C가 B를 상속했을 때, 상속을 통해 클래스의 크기는 점점 커진다.
- C클래스 인스턴스를 선언하면 생성자 호출순서는 C->B->A다. 하지만 가장 먼저 실행되는 생성자는 C가 아니라 A다. C의 클래스 인스턴스가 소멸하면 C클래스의 소멸자가 가장 먼저 호출되고 실행된다. 즉, "생성자는 호출과 실행 순서가 역순이고 소멸자는 같다"
- 파생 클래스는 부모 클래스의 멤버 변수에 직접 쓰기 연산하지 않는 것이 정답이다. 파생 클래스 생성자에서 부모 클래스 멤버 변수를 초기화하지 않는다.
```
- 생성자와 소멸자는 객체 자신의 초기화 및 해제만 생각하는 것이 맞다.
```
