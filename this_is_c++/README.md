# C++ 프로그래밍과 STL
## ch01. 객체지향 프로그래밍의 개념
- 구조적 프로그래밍처럼 프로그래머가 순차적으로 구성한 시나리오에 의해 기능이 수행되는 것이 아니라,
실행 중에 사용자가 마음 가는 대로 기능을 선택하면, 그 기능을 수행하도록 하는 방식이다. 객체 지향프로그래밍은 이와 같은 구성 방식을 가지고 있다고 생각하면 쉽다.
- 은닉된 데이터는 외부로부터 숨기고, 외부로는 멤버함수만 공개하여 은닉된 데이터를 접근할 수 있는 방법은 오직 멤버함수로 제한하였다.
### 다형성(polymorphism)
1. 오버로딩(overloading) : 같은 이름, 다른 전달인자의 타입과 전달인자의 개수.
2. 오버라이딩(overriding) : 재정의

## ch02. C에서 C++로 확장
### 인라인 함수(inline function)
- 멤버함수의 정의가 아주 짧으면, 크래스 선언 내부에 직접 함수를 정의할 수 있다. 클래스 내부에 직접 함수를 정의하게 되면 inline 키워드를 굳이 붙이지 않아도 인라인 함수가 된다.
- 장점
1. 인라인 함수의 전달인자에 데이터 형을 체크할 수 있다.
2. 매크로가 갖는 부작용 없이 일반 함수처럼 사용이 가능하다.
3. 디버깅이 가능하다.
- 단점
1. 실행 코드가 커진다
2. 인라인 함수의 구현을 짧게 해야 한다. 길다면, 컴파일러는 이를 일반 함수로 취급하게 된다.

## ch03. 클래스의 기본
- 클래스란 사용자가 정의한 추상적인 데이터형(Abstract Data Type)이라고 할 수 있다.
- 클래스는 기본이 private, 구조체는 접근 지정자의 기본이 public. c++에서 데이터 멤버만을 사용할 때는 구조체를 사용하되, 멤버변수 및 멤버함수를 모두 사용하는 경우는 클래스를 사용하도록 하자.
#### 객체 생성
```c++
MousePoint point;
// 변수를 선언하듯이 MousePoint 클래스 명을 쓰고, 그 뒤에 point라는 객체 이름을 선언하였다.
// MousePoint 클래스가 바로 사용자가 정의한 자료형이고, point가 실질적인 프로그래밍을 하게 할 객체이다.
```
#### 멤버함수
- 클래스는 데이터인 멤버 변수를 은닉화시키고, 은닉화된 멤버변수를 컨트롤 할 수 있는 유일한 게이트로 멤버함수를 정의한다.

#### 생성자
- 객체 생성 시 자동으로 초기화를 해주는 특별한 초기화 전용 멤버함수를 제공하고 있는데, 이것이 바로 생성자(Constructor)이다.
- 특징
1. 생성자의 이름은 클래스의 이름과 동일하다
2. 생성자의 타입은 지정하지 않는다
3. 생성자의 호출은 객체 선언 시 자동으로 호출되다
4. 반환값을 지정하지 않는다
5. 디폴트 생성자가 존재한다.

#### 소멸자
- 특징
1. 클래스의 이름을 그대로 사용한다. ~틸드 기호를 붙인다.
2. 소멸자 타입은 지정하지 않는다
3. 객체 소멸 시 자동으로 호출된다. 인위적으로 호출할 수 있는 함수가 아니다
4. 반환값을 지정하지 않는다.
5. 전달인자를 지정하지 않는다.
6. 생성자처럼 오버로딩이 되지 않는다.
 
## ch04. 클래스의 특징과 객체 활용
#### 객체 배열
```c++
MousePoint pt[3];
// pt라는 객체가 3개 선언되어있따는 의미이다. 각 객체별로 별도의 메모리를 할당받는다. 즉(멤버변수도 객체별 메모리를 각각 할당받되, 멤버함수는 3개의 객체가 공유한다)
```
#### 객체 포인터
```c++
MousePoint *pObj;
// 객체 포인터는 객체의 주소값을 저장하기 위한 변수이며 객체를 간접 참조하기 위해 사용한다.

MousePoint pt(10, 20);
pObj = &pt;
cout << pObj->Getx() << '\n'; // 10을 출력.
```

#### this 포인터
- this 포인터가 필요한 이유
	- 각 객체함수가 멤버함수를 호출하면 당연히 자기 자신이 갖고 있는 데이터를 멤버함수가 사용할 것이라고 생각한다. 하지만, 멤버함수 입장에서 생각해보자. 어떤 객체가 자신을 호출했는가?
	- 이때 필요한 정보가 this 포인터이다.
- this 포인터는 호출한 객체를 가리키는 const포인터이다.
```c++
void MousePoint::SetXY(int x, int y)
{
	this->x = x;
	this->y = y;
	// 멤버 변수를 나타내는 x, y는 this 포인터를 붙여줌으로써 현재 호출한 객체의 멤버변수임을 명시할 수 있다.
}
```
### 객체에 대한 값 전달 방식 p82
### 객체에 대한 
#### 전달인자가 객체인 함수

## ch05. 클래스와 동적 메모리 할당
## ch06. 연산자 오버로딩
## ch07. 상속성(inheritance)
## ch08. 다형성(polymorphiysm)
## ch09. 다중상속(multiple inheritance)
## ch10. 템플릿(Template)
## ch11. 예외처리(exception handling)
