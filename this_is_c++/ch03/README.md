## 클래스
- 객체란 변수들과 그와 관련된 메서드들이 모여서 이룬 하나의 꾸러미이다.
- 클래스란 C의 구조체에서 확정된 변수, 객체, 함수를 포함한 하나의 틀이다.
- 객체지향 프로그래밍에서는 클래스를 가져다 사용하는 '사용자'를 배려해야 한다. 즉 사용자의 편의성을 극대화 하려고 하면서, 사용자의 실수 가능성을 최대한 차단해야 한다.

### 1. 객체지향 [프로그래밍](프로그래밍)
### 2. 클래스 기본 문법
### 2-1. 멤버 선언 및 정의
### 2-2. 접근 제어 지시자
- public : 멤버에 관한 모든 외부 접근 허용
- protected : 상속 관계에 있는 파생 클래스에서의 접근만 허용
- private : 외부 접근뿐만 아니라 파생 클래스로부터의 접근까지 모두 차단. 기본값 private
### 3-3. 생성자와 소멸자
- 생성자는 다중 정의할 수 있고, 소멸자는 다중 정의 할 수 없다.
```
- 전역 변수로 선언한 클래스의 생성자가 main() 함수보다 먼저 호출된다!
```
- main함수가 끝난 후 소멸자가 호출될 수 있다.
- 생성자와 소멸자는 생략할 수 있으나 생략할 경우 컴파일러가 만들어 넣는다.
- 새로운 생성자를 만들면서 디폴트 생성자를 생략할 수 있다. (디폴트 생성자 생략 후 디폴트 값 생성은 허용되지 않는다)
- 생성자는 다중 정의 할 수 있지만 소멸자는 다중 정의 할 수 없다.
#### 동적 객체의 생성과 소멸
- 배열로 생성한 객체들은 반드시 배열로 삭제한다.
#### 참조 형식 멤버 초기화
- 참조자는 반드시 선언과 동시에 초기화해야 한다.
- 참조형 멤버는 객체가 생성될 때 반드시 초기화한다.
- 참조형 멤버는 반드시 생성자 초기화 목록을 이용해 초기화한다. 
```c++
class CRefTest
{
public:
	CRefTest(int &i_param) { m_i_data = i_param; }; // 초기화가 아니다 단순 대입이다.
	CRefTest(int i_param) : m_i_data(i_param); // 생성자의 매개변수가 참조 형식이 아니면 내부의 자동변수와 같으므로, 함수 반환 시 소멸한다. 즉 m_i_data = i_param 결국 사라질 대상에 대한 초기화인 것이다. 
	CRefTest(int &i_param) : m_i_data(i_param);
private:
	int &m_iData;
}

```

	CRefTest(int &i_param) { m_i_data = i_param; };
	// 여기서 =는 단순히 대입 연산자에 불과하다. 따라서 위 코드는 선언 및 정의가 아니고 이미 선언된 인스턴스를 이용해서 연산하는 것에 불과하다.
	CRefTest(int i_param) : m_i_data(i_param) { };
	// 참조자가 가리키는 원본이 삭제됐기에 쓰레기값이 출력될 수 있다.함수의 매개변수는 함수 내부의 자동 변수와 같으므로 함수가 반환될 때 매개변수는 소멸된다. 즉 m_i_data(i_param)이란 결국 사라질 대상에 대한 참조자가 초기화되는 결과를 초래한다.
#### 생성자 다중 정의
- 다중 정의 보다는 추가로 부르는 생성자 함수를 사용하자.
```c++ 
CMypoint(int x) { }
CMypoint(int x, int y) : CMypoint(int x) { } // 코드의 재사용
```
#### 명시적 디폴트 생성자
```c++
CTest(void) = default // 템플릿을 이용할 때 많이 사용한다.
```
### 3-4. 메서드
- 사람 객체는 달리기라는 기능이 있어.
```c++
사람 준혁;
준혁.달리기();
```
- 자동차는 '방향'이라는 멤버변수를 가졌는데 이 값을 '핸들'이라는 메서드로 제어할 수 있어.
```c++
자동차 붕붕이;
붕붕이.핸들(왼쪽, 10도);
```
- 자동차의 핸들은 운전자와 자동차를 이어주는 전형적인 인터페이스이다. 따라서 멤버 함수는 상황에 따라 '인터페이스 함수'라고 한다.
- 멤버 함수의 원형
```c++
static 반환자료형 클래스이름::함수이름(매개변수) const;
```

|                  | 일반                 | 상수화                | 정적                 | 가상                     |
|------------------|----------------------|-----------------------|----------------------|--------------------------|
| 관련 예약어      |                      | const                 | static               | virtual                  |
| this 포인터 접근 | 가능                 | 가능                  | 불가능               | 가능                     |
| 일반 멤버 읽기   | 가능                 | 가능                  | 가능(제한)           | 가능                     |
| 일반 멤버 쓰기   | 가능                 | 불가능                | 가능(제한)           | 가능                     |
| 적정 멤버 읽기   | 가능                 | 가능                  | 가능                 | 가능                     |
| 적정 멤버 쓰기   | 가능                 | 불가능                | 가능                 | 가능                     |
| 특징             | 가장 보편적인 메서드 | 멤버 쓰기 방지가 목적 | C의 전역 함수와 유사 | 상속관계에서의 의미가 큼 |
#### this 포인터
```
- 작성 중인 클래스의 실제 인스턴스에 대한 주소를 가리키는 포인터이다.
```
- this 포인터는 휴대폰 시리얼 번호다. 제품을 설계하고 제작하는 과정이 아니라 '생산 단계'에서 결정 된다. 그런데 제작자는 아직 결정되지 않은 시리얼 번호를 이용해야 하는 프로그램 코드를 작성해야 할 수 있다. 이때 현재 시점에서 미래의 시리얼 번호에 접근하는 것이 this포인터이다.
- 호출자 함수 쪽에서 인스턴스의 주소를 넘겨줄 수 있도록 허용한다면 잘못된 주소를 받을 가능성이 생긴다. 따라서 이런 실수를 허용하지 않도록 설계하기 위해 this 포인터가 생겨난 것이다.

## this 포인터와 *this가 헷갈려서 찾아봤는데 좋은 예시코드가 있다.
```c++
#include <iostream>

class Foo
{
    public:
        Foo()
        {
            this->value = 0;
        }

        Foo get_copy()
        {
            return *this;
        }

        Foo& get_copy_as_reference()
        {
            return *this;
        }

        Foo* get_pointer()
        {
            return this;
        }

        void increment()
        {
            this->value++;
        }

        void print_value()
        {
            std::cout << this->value << std::endl;
        }

    private:
        int value;
};

int main()
{
    Foo foo;
    foo.increment();
    foo.print_value();

    foo.get_copy().increment();
    foo.print_value();

    foo.get_copy_as_reference().increment();
    foo.print_value();

    foo.get_pointer()->increment();
    foo.print_value();

    return 0;
}
===========
1
1
2
3
```
#### 상수형 메서드
```
const는 this 포인터를 상수형 포인터로 변경하는 것이다.
```
- 상수형 메서드는 절대로 멤버 변수의 값을 쓸 수 없고, 상수형 메서드가 아닌 멤버는 호출할 수 없다.
- c++에선 const가 '안전 장치'이자 '배려'이다. const 갯수만 세어봐도 코드 작성자의 수준을 알 수 있다.
#### 상수형 메서드 예외사항
- 상수화된 대상에서 const에약어가 지정된 멤버를 뽑아 값을 쓰거나 호출할 수 있다.
	- mutable
```
mutable로 선언한 멤버 변수의 값은 상수형 메서드에서도 쓰기가 허용
```
	- const_cast<>
```
상수형 참조인 경우 참조자를 통해 참조 원본에 접근하더라도 읽기만 허용될뿐 쓰기는 불가능하다. 그러나 가끔은 억지로 쓰기를 해야 하는 경우가 있는데 이럴 때 사용한다.

const_cast<새형식>(대상)
```
#### 멤버 함수 다중 정의
```c++
// 멤버 변수 int, 매개변수로 double이 들어올 때 실수 5.5가 5로 출력된다.
void set_data(double d_param) = delete // 실수로 double 자료형 실인수가 넘어오는 경우를 차단한다.
```
### 3.5 정적 멤버
- 사용자 코드에서 특정 클래스의 메서드를 호출하고 싶다면 무조건 인스턴스를 선언하거나 new 연산으로 동적 인스턴스를 생성하고 멤버 접근 연산자를 통해 호출해야 한다.
- 이럴 필요가 없는 함수를 만들어야 할 때가 있을 때 대부분 전역함수를 만들려고 한다.
- 객체지향 프로그래밍에서 소속 객체가 없이 스스로 존재하는 전역 함수들은 좋은 설계를 역행하거나 불필요한 의존 관계를 만드는 원인이 될 수 있기 때문에 전역 함수 사용을 지양해야 한다.
- 여기서 나온 대안이 '정적 멤버'이다. 이는 사실상 전역 변수나 함수와 같다.
1. 인스턴스를 선언하지 않고 직접 호출할 수 있다.
2. this 포인터를 사용할 수 없으며 정적 변수는 반드시 선언과 정의를 분리해야 한다.
