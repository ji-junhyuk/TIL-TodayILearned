### 10.1 try, throw, catch문
```c++
try
{
	... // 작업 1
	if (error 발생)
		throw errorcode;
	... // 작업 2
	if (error 발생)
		throw errorcode;
	catch (int i_exp)
	{
		...
		}
```
- if-else 문은 정상적인 작동과 그렇지 않은 경우에 대응하는 코드가 뒤섞여 코드가 복잡해 보일 수 있다. 즉 구조가 간결해진다. 단, 구조화된 예외처리는 언제까지나 선택이다.
#### catch 다중화
- catch문을 여러개로 구현할 수 있다. 이렇게 하면 switch-case문이나 다중 if 문에 의한 분류만으로 에외를 처리하지 않아도 된다.
```c++
try
{
}
catch(...) 
{
	try
	{
	}
	catch(...)
	{
	}
}
예외를 다루는 과정에서 또 다시 예외가 발생하는 경우를 대비하는 구조도 가능하다.
```
#### 예외 클래스
- 사용자 정의 클래스도 포함된다.
```c++
catch (CMyException &exp) //  다음과 같은 코드를 사용할 수 있다.
```
### 10.2 스택 풀기(stack unwinding)
- 쌓아 올려진 스택이 정상적으로 줄어들도록 하려면 호출한 함수가 모두 반환되도록 코드를 작성해야 한다. 구조화된 예외 처리를 이용한다면 그 상황에 맞는 코드를 별도로 만들필요가 없다.
### 10.3 메모리 예외 처리
- bad_alloc클래스는 exception클래스의 파생 클래스이며, what() 메서드를 호출하면 에외가 발생한 이유를 확인할 수 있다. 
```
catch (bad_alloc &exp)
{
	cout << exp.what() << '\n'; // 시스템이 밝힌 원인을 출력한다.
};
```
