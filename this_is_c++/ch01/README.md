### 인스턴스와 입출력 흐름
```c++
int a;
string strdata;
```
- a는 int 자료형에 대한 인스턴스고 strdata는 string 자료형에 대한 인스턴스다. C++에서는 '변수'라는 표현보다는 '인스턴스'라는 표현에 익숙해져야 한다. 객체지향 프로그래밍 환경에서는 모든 것을 다 객체로 표현하고 객체의 형식을 갖는 변수를 인스턴스라고 하기 때문이다.
### 변수 선언 및 정의
```c++
int a = 10;

int a(10); // 10은 int 자료형 a의 초깃값이다.
int b(a); // b는 a를 복제해서 만든다.
```

### auto 자료형
초기값의 형식에 맞춰 선언하는 인스턴스의 형식이 '자동'으로 결정된다.

## 메모리 동적 할당
### new와 delete 연산자
```c++
형식 *변수이름 = new 형식;
delete 변수이름;

형식 *변수이름 = new 형식[요소개수]
delete[] 변수이름;
```
- new 연산자를 malloc()함수와 비교했을 때 가장 도드라진 특징 중 하나는 "메모리 크기를 정하지 않는다"는 점이다. 자료의 '형식'속에는 필요한 메모리 크기도 포함된다. 이 때문에 보통 sizeof 연산을 통해 크기를 직접 계산하기도 하지만, new 연산자는 그럴 필요가 없다.
- 배열 형태로 동적 생성한 것은 반드시 배열을 형태를 통해 삭제하여야 한다.
```
new 연산자는 객체의 생성자를 호출하고, delete 연산자는 객체의 소멸자를 호출한다.
```

### 참조자 형식
```c++
형식 &이름 = 원본;
```
- 참조자(reference)는 C에는 없는 형식으로 포인터와 구조적으로 비슷하다. 선언과 동시에 초기화해야 한다.
```
상수에는 참조자를 선언할 수 없다!
```
```c++
int *pdata = &3; // 불가능;
int &r_data = 3; // 상수에 대한 참조는 불가능
int &r_data; // 참조 원본이 없으므로 불가능
```
- 덩치 큰 자료는 값이 아니라 '주소'를 전달하는 것이 효율적이다!
```c++
void test_func(int &rParam)
{
	rParam = 100;
}

int main()
{
	int iData = 0;
	test_func(iData); // 주의할 점은 매개변수가 참조자인 경우 호출자 코드만 봐서는 매개변수가 참조형식이라는 사실을 알 수 없다는 것!!
	cout << iData << '\n';
	// 100출력
}
```

### r-value 참조
- r-value란 대입 연산자의 두 피연산자 중 오른쪽에 위치한 연산자를 말하는 것으로, 일반적인 변수와 상수 모두 해당될 수 있다.
```c++
int &&iData = 3;
```

```c++
int &rData = iInput + 5; // 임시 객체에 대한 r-value 참조
int &&result = testfunc(10); // 임시 객체에 대한 
```
- 3 + 4 + 5에서 3 + 4 의 연산 결과를 '임시 결과'라고 한다. 이어지는 +5 연산에 참여하는 것은 3, 4가 아닌 그 둘이 만든 '임시 결과'임을 잊지 말자!
### 범위기반 for
- 보통의 for문은 배열의 요소가 선언할 때 확정된다(for (int idx = 0 ...)
- 범위 기반 for문
```c++
for (auto 요소변수 : 배열이름)
```
- 배열의 요소가 5개에서 10개로 변경된다면 보통의 for문은 수정해야 하지만, 범위기반 for문은 그럴 필요가 없다.
- 배열의 요소의 값을 변경한다면 이렇게 사용하자!
```c++
for (auto &n : iList)
	;
```

