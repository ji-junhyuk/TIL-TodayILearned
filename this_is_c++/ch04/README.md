## 4장.복사 생성자와 임시 객체
### 4.1 복사 생성자
- 객체의 복사본을 생성할 때 호출되는 생성자이다.
```c++
클래스이름(const 클래스이름 &rhs)
// 매개변수 이름을 rhs. right hand side의 약자. 즉 r-value라고 보기 대문이다. const예약어는 생략할 수 있지만 특별한 이유가 없다면 붙이는 것이 원칙이다.
```
- 매개변수가 참조자가 되었을 때 한가지 단점이 있다. 사용자의 코드만 보고서는 참조에 의한 호출(call by reference)인지 아닌지 알 수 가 없다.'
- 하지만 댕글링 포인터 문제나 의존 관계 분석 불가로 인한 코드 최적화 실패 등을 방지할 수 있다. 따라서 참조자로 대체할 수 있는 포인터는 무조건 대체하는 것이 좋다.
- 사용자 쪽에서 call by value인지 아닌지 알아야 하는 이유는 함수의 실인수로 기술한 변수가 함수 호출 때문에 값이 변경될 수 있기 때문이다.
- 그러므로 함수의 형식이 클래스 형식이라면 일단, 아니 무조건 상수형 참조로 선언해야 한다.
- 불필요하게 객체를 호출하며 복사 생성자가 생성되는 경우를 막을 수 있기 때문이다.
### 4.1 복사생성자
```c++
클래스이름(const 클래스이름 &rhs);
```
- 함수 호출과 복사 생성자
```c++
void test_func(CTest param) { }

void main()
{
	CTest a; // 객체의 복사본으로 생성
	test_func(a); // 함수 형태로 호출
}
```
- 반환 형식으로 사용되는 경우 '이름 없는 임시 객체'를 만들어 내는 문제가 발생할 수 있다.
- 복사 생성자를 삭제하는 방법이 아닌 매개변수를 참조자로 하였을 때 사본을 만들어내지 않고 호출하여 성능이 향상된다.
- 함수의 실인수로 기술한 변수가 함수 호출 때문에 값이 변경될 수 있기에 함수의 매개변수 형식이 클래스 형식이라면 무조건 상수형 참조로 선언해야 한다.
#### 깊은 복사와 얖은 복사
- 깊은 복사는 복사에 의해 실제로 두 개의 값이 생성되는 것이고 '얕은 복사'는 대상이 되는 값은 여전히 하나뿐인데 접근 포인터만 둘로 늘어나는 것을 말한다.
```c++
int *pa, *pb;
pa = new int;
*pa = 10;

pb = new int;
pb = pa; //얕은 복사. pb는 pa가 동적 생성한 int 인스턴스를 가리키게 된다. delete pa; delete pb; 를 할 경우 해제한 포인터를 다시 해제하려고 하는 오류가 발생함.

*pb = *pb; // 깊은 복사. 단순히 포인터 변수의 주소를 같은 값으로 만드는 게 아닌 pa포인터가 가리키는 대상 메모리에 저장된 값을 가져와 pb포인터가 가리키는 대상 메모리로 복사한 것이다.
```
- 복사 생성자의 경우 기본적으로 얕은 복사를 진행한다. 하지만, 클래스 내부에서 메모리를 동적 할당 및 해제하고 이를 멤버 포인터 변수로 관리하고 있는 경우에는 깊은 복사를 할 수 있게 복사생성자를 정의해주어야 한다.
```c++
CMydata(const CMydata &rhs)
{
	m_piData = new int;
	*m_piData = *rhs.m_piData;
}
```
#### 대입연산자
- 단순 대입 연산자가 구조체나 클래스에도 기본적으로 적용된다.
- 단순 대입 연산자의 동작 방식을 수정할 수 있다.
```c++
// 클래스 a, b 가 있을 때, a = b가 깊은 복사를 진행할 수 있게 단순 대입연산자를 정의해보자.
CMyData &operator=(const CMyData &rhs)
{
	*m_p_i_data = *rhs.m_p_i_data;
	return *this;
}
```
### 4.2 묵시적 변환
#### 변환 생성자
- 변환 생성자가 은근슬쩍 호출 될 수 있다. 이는 불필요한 임시 객체를 만들어내어 프로그램의 효율을 갉아먹는 원인이 된다.
- 덩치가 제법 나가는 객체라면 묵시적 변환 생성자가 사용자 모르게 호출 될 가능성을 차단하는 것이 바람직하다.
```c++
public:
	CTestData(int iParam) : m_iData(iParam)
explicit // 사용자 코드에서 묵시적으로 변환이 일어나게끔 하여 임시 객체가 생성되지 못하게 한다. 즉, 사용자 코드에서 직접 변환 형식을 지정해야 한다는 이유로 컴파일을 오류를 발생시킨다.
```
## 음.
- 클래스 형식을 매개변수로 사용할 것이라면 무조건 참조 형식을 사용하라고 했던 것을 기억합니까?
- 묵시적 변환 생성자를 지원하는 클래스인지도 꼭 확인해야한다. (덩치가 제법 나가는 객체라면 묵시적 변환 생성자가 사용자 모르게 호출될 가능성을 차단하는 것이 바람직하다.)
#### 허용되는 변환
```c++
class CTestData
{
	public: 
	...
	operator int(void) { return m_i_data } // CTestData클래스는 int 자료형으로 변환 될 수 있다!
}
int main()
{
	CTestData a(10);
	
	cout << a ;// CTestData 에서 int 자료형으로 변환될 수 있다!!
}
====================================
	explicit operator int(void) { return m_i_data } // 형변환 연산자에도 변환 생성자처럼 explicit 예약어를 적용할 수 있다!
// 에러가 발생한다.
cout << a << '\n'; // a가 int 자료형으로 '묵시적'으로 변환될 수 없기 때문이다. 따라서 이렇게 호출해야한다.
cout << static_cast<int>a << '\n'; // 클래스에 묵시적인 형변환 연산자를 제공한다면 사용자는 그만큼 편하다. 꼭 explicit 선언을 강제할 필요는 없다!
```
- 클래스의 형변환 연산자에도 변환 생성자처럼 explicit 예약어를 적용할 수 있다.
##### c++에서 형변환 연산자의 종류
- [const_cast](const_cast)
- dynamic_cast
- static_cast
- reinterpret_cast

### 4.3 임시 객체와 이동 시맨틱
- 변환 생성자가 묵시적으로 호출되는 것을 explicit 예약어로 막으려는 이유는 사용자 코드에서 보이지 않는 객체가 생성되고 소멸하는 것을 막기 위함이다.
- 함수의 반환 형식이 클래스인 경우 이보다 더 은밀한 이름 없는 임시 객체가 있다.
```
- 이름 없는 임시 객체의 원본은 임시 객체의 복사 생성이 끝난 후 소멸한다.
```
- 함수가 반환되면서 임시 객체가 생성됐다가 대입 연산 후 즉시 소멸한다. (이름 없는 임시 객체의 원본은 임시 객체의 복사 생성이 끝나고 소멸한다)
#### r-value 참조
- r-value는 단순 대입 연산자의 오른쪽 항을 말한다. int 자료형에 대한 참조는 int &이다. 하지만 int 자료형에 대한 r-value 참조 형식은 int &&이다.
- r-value 라는 것이 '연산에 따라 생성된 임시 객체'라는 것이다.
```c++
void TestFunc(int &&rParam)
{
	cout << "TestFunc(int &&)" << '\n';
}

int main()
{
	TestFunc(3 + 4);
}
```
#### 이동 시맨틱
- 이동시맨틱(Move semantics) : 이동생성자와 이동 대입 연산자로 구현된다.
- 복사 생성자와 대입 연산자에 r-value 참조를 조합해서 새로운 생성 및 대입의 경우를 만들어낸 것을 말한다.
- 어차피 사라질 객체이므로 깊은 복사를 수행하는 것이 아니라 얕은 복사를 수행함으로써 성능을 높이는 것이다.
```c++
b = TestFunc(a); // TestFunc 는 class 를 return한다. 어차피 사라질 임시 객체이므로 얕은 복사만 수행하여 알멩이는 빼내고 껍데기만버리는 것이다.
```
