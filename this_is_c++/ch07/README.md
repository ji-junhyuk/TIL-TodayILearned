### 7.1 가상함수
- virtual 예약어를 앞에 붙여서 선언한 메서드를 말한다. 따라서 가상 함수라는 메서드라는 말을 내포하며, 이 가상함수는 기본적으로 '자기 부정'을 전제로 작동한다. 달리 말해 파생 형식에서 메서드를 재정의하면 과거의 정의가 완전히 무시된다.
```c++
virtual 반환형식 메서드이름
virtual void print_data();
```
## 일반 메서드는 참조 형식을 따르고, 가상 함수는 실 형식을 따른다.
- 일반 메서드의 경우 실 형식은 중요하지 않고 참조 형식이 무엇인지에 따라 어떤 메서드가 호출되는지 결정이 났지만 가상함수는 다르다. 가상 함수는 일반 함수와 달리 참조 형식이 무엇이든 실 형식의 메서드를 호출한다.
- 만일 파생 형식에서 print_data() 가상 함수를 재정의한다면 현재의 19번 행 코드(과거의 코드)로 '미래'의 함수를 호출하는 것이다. 즉, 가상함수는 호출하는 것이 아니라 호출되는 것이다!
- 어떤 클래스가 어떤 가상 함수를 가졌고 언제 호출되는지 정확히 알아야 한다.
- 특정 가상함수가 미래에 재정의되는 것을 막고 싶다면,
```c++
virtual void print_data() final;
```
#### 소멸자 가상화
```c++
CMydata *p_data = new CMydataEx;
//상위 클래스로 하위 파생 클래스를 참조할 때 상위 클래스 형식을 '추상 자료형(ADT)'라고 한다.
// 이 추상자료형을 이용해 동적 생성한 객체를 참조한 경우  파생 형식의 소멸자가 호출되지 않는 잠재적인 문제가 있다.
```
- 참조형식의 생성자만 호출되고 실 형식의 생성자가 호출되지 않는 심각한 내부적 문제가 발생한다.
- '소멸자를 가상화'하여 파생 클래스의 소멸자까지 제대로 호출되게 해야 한다.
```c++
virtual ~CMydata()
{
	delete m_psizeD;
}
// 
```
### 7.2 가상 함수 테이블(vtable)
- vtable이라는 것은 '함수 포인터 배열'이라고 볼 수 있다.
- 디버깅을 하게 되면 this 포인터 아래 __vfptr이라는 지역변수가 있다. 이 포인터를 따라가면 가상 함수로 선언된 멤버 함수들의 주소에 배열 형태로 접근할 수 있다.
- 바인딩이란 함수나 변소의 주소가 결정되는 것을 말한다. 컴파일 타임에 결정되면 이른 바인딩(early binding)이고, 런타임 도중 결정되면 늦은 바인딩(dynamic binding)이라 한다.
### 7.3 순수 가상 클래스(pure virtual class)
- 순수 가상 함수를 멤버로 가진 클래스를 말한다.
```c++
virtual int get_data() const = 0;
```
```
- 인스턴스를 직접 선언할 수 없다. 
- 순수 가상 클래스의 파생 클래스는 반드시 기본 클래스의 순수 가상 함수를 재정의해야 한다.
- 추상 자료형으로 CMydata 클래스의 인스턴스를 참조한다 하더라도 가상함수이므로 실 형식을 따르므로 어떤 경우라도 늘 CMydata 클래스의 함수가 호출된다.
```
- 가상함수는 추상 자료형으로 참조하더라도 언제나 실 형식의 메서드가 호출됨을 잊지 말자.
#### 추상 자료형 사용 예
- 성능 상의 문제로 반드시 생각해봐야 할 문제
	- 사용자가 입력할 수 있는 모양의 종류는 몇 가지 인가요?
	- 사용자가 입력한 모양을 화면에 출력할 때 어떤 모양인지에 따라 각각 다른 함수가 호출되도록 코드를 작성할 것인가요?
	- 사용자가 입력한 모양이 무엇인지 판단하기 위해 switch-case 문을 사용할 것인가요?
- 빠른 연산이 필요한 경우에 switch 나 다중 if문은 매우 비효율적이다. (사용자 입력 시간에 처리하도록)
#### 인터페이스 상속
- 다른 장치들과 상호작용할 생각이라면 가장 많이 사용되는 보편적 인터페이스를 선택함으로써 어디든 사용할 수 있게 설계하는 것이 좋다.
### 7.4 상속과 형변환
- static_cast<>
	- 상속 관계일 때 파생 형식을 기본 형식으로 포인팅할 수 있다.
	- 상향 형변환은 묵시적으로 이루어질 수 있으나 하향 형변환은 상속 관계에서만 가능하다.
```c++
CMydata *p_data = new CMydataEx; // 파생 형식의 객체를 기본 형식으로 포인팅한다.
CMydataEx *p_new_data = NULL;
p_new_data = static_cast<CMydataEx*>(p_data); // 기본 형식에 대한 포인터이나 가리키는 대상은 파생 형식이다. 따라서 파생 형식에 대한 포인터로 형변환을 시도한다.
```
- pNewData = statc_cast<CMydataEx*>(pData);
	- CMydata* 형식인 pData의 값을 CMydataEx* 형식으로 변환한다는 의미이다.
- dynamic_cast<> 
	- 동적으로 생성된 어떤 객체가 있을 때 그것을 가리키는 포인터가 기본 형식인 경우라면 구체적으로 어떤 객체에 대한 인스턴스인지 확인할 때 쓰는 것이다.
	- 꼭 필요한 경우가 아니라면 쓰지 말아야 한다.
### 7.5 상속과 연산자 다중 정의
- 상속받은 클래스에서 연산자 함수를 만들어 넣는 방법.
- using 키워드를 통해 상위 클래스의 연산자 함수드를 그대로 차용한다고 선언하는 방법.

### 7.6 다중 상속
```c++
class CMyPicture : public CMyImage, public CMyShape
```
- 족보가 엉켰을 때 가상 상속으로 풀어준다. (virtual)
- 유일하게 사용해도 좋은 경우는 인터페이스 상속이다.
